{
  "code": 200,
  "data": [
    {
      "id": 1,
      "title": "cross-env 运行跨平台设置和使用环境变量的脚本",
      "time": "2021-08-23 14:11",
      "abstract": "运行跨平台设置和使用环境变量的脚本; 出现原因 当您使用 NODE_ENV=production, 来设置环境变量时，大多数 Windows 命令提示将会阻塞(报错)。（异常是Windows上的Bash，它使用本机Bash。）",
      "type": ["JavaScript","Node.js"],
      "content": "<h5 id=\"2111-cross-env是什么\">1.1 cross-env是什么</h5>\n<p>运行跨平台设置和使用环境变量的脚本</p>\n<h5 id=\"2112-出现原因\">1.2 出现原因</h5>\n<p>当您使用 NODE_ENV=production, 来设置环境变量时，大多数 Windows 命令提示将会阻塞(报错)。（异常是Windows上的Bash，它使用本机Bash。）换言之，Windows 不支持 NODE_ENV=production 的设置方式。</p>\n<h5 id=\"2113-解决\">1.3 解决</h5>\n<p>cross-env 使得您可以使用单个命令，而不必担心为平台正确设置或使用环境变量。这个迷你的包(cross-env)能够提供一个设置环境变量的 scripts，让你能够以 Unix 方式设置环境变量，然后在 Windows 上也能兼容运行。</p>\n<h5 id=\"2114-安装\">1.4 安装</h5>\n<div class=\"cnblogs_code\">\n<pre>npm install --save-dev cross-env</pre>\n</div>\n<p>&nbsp;</p>\n<h5 id=\"2115-使用\">1.5 使用</h5>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: #000000;\">{\n  </span>\"scripts\"<span style=\"color: #000000;\">: {\n    </span>\"build\": \"cross-env NODE_ENV=production webpack --config build/webpack.config.js\"<span style=\"color: #000000;\">\n  }\n}</span></pre>\n</div>\n<p>&nbsp;</p>\n<p>NODE_ENV环境变量将由 cross-env 设置 打印 process.env.NODE_ENV === 'production'</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>例如，webpack很多都有设置如下：</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> Source maps are resource heavy and can cause out of memory issue for large source files.</span>\nconst shouldUseSourceMap = process.env.GENERATE_SOURCEMAP !== 'false';</pre>\n</div>\n<p>此时 该判断在打包的时候，会一直默认是需要map文件的， 其本身是有三种方式处理：</p>\n<p>1： 根目录下创建 .env文件，并增加一句参数</p>\n<div class=\"cnblogs_code\">\n<pre>GENERATE_SOURCEMAP=<span style=\"color: #0000ff;\">false</span></pre>\n</div>\n<p>2： 将改语句改为：</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> Source maps are resource heavy and can cause out of memory issue for large source files.</span><span style=\"color: #008000;\">\n//</span><span style=\"color: #008000;\"> const shouldUseSourceMap = process.env.GENERATE_SOURCEMAP !== 'false';</span>\n const shouldUseSourceMap = <span style=\"color: #0000ff;\">false</span>;</pre>\n</div>\n<p>3: 就用到我们这个插件，在package.json中创建一个用于不生成sourcemap的打包命令：</p>\n<div class=\"cnblogs_code\">\n<pre> \"scripts\"<span style=\"color: #000000;\">: {\n    </span>\"start\": \"node scripts/start.js\"<span style=\"color: #000000;\">,\n    </span>\"build\": \"node scripts/build.js\"<span style=\"color: #000000;\">,\n    </span><span style=\"color: #ff6600;\">\"build-p\": \"cross-env GENERATE_SOURCEMAP=false node scripts/build.js\",\n    </span>\"test\": \"node scripts/test.js\"<span style=\"color: #000000;\">\n  },</span></pre>\n</div>\n<p>&nbsp;</p>"
    },
    {
      "id": 2,
      "title": "TypeScript - 属性的修饰符",
      "time": "2021-08-06 17:10",
      "type": ["TypeScript","JavaScript"],
      "abstract": "TS 可以在属性前增加属性的修饰符; public 修饰的属性可以再任意位置访问（修改）默认值; private 私有属性，私有属性只能在类内部进行访问和修改",
      "content":"<div class=\"cnblogs_code\">\n<pre><span style=\"color: #000000;\">class Person {\n    </span><span style=\"color: #008000;\">/*</span><span style=\"color: #008000;\">*\n     * TS 可以在属性前增加属性的修饰符\n     * public 修饰的属性可以再任意位置访问（修改）默认值\n     * private 私有属性，私有属性只能在类内部进行访问和修改\n     </span><span style=\"color: #008000;\">*/</span><span style=\"color: #000000;\">\n\n    public title: string; </span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> 不加前缀其实就是public</span>\n<span style=\"color: #000000;\">    private name: string;\n    private age: number;\n\n    </span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> 可以将前缀写在此处</span>\n    <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> constructor(public title: string, private name: string, private age: number) {</span>\n<span style=\"color: #000000;\">\n    constructor(title: string, name: string, age: number) {\n        </span><span style=\"color: #0000ff;\">this</span>.title =<span style=\"color: #000000;\"> title;\n        </span><span style=\"color: #0000ff;\">this</span>.name =<span style=\"color: #000000;\"> name;\n        </span><span style=\"color: #0000ff;\">this</span>.age =<span style=\"color: #000000;\"> age;\n    }\n\n    </span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> 可用get set方式来实现getName和setName</span>\n<span style=\"color: #000000;\">    getName() {\n        </span><span style=\"color: #0000ff;\">return</span> <span style=\"color: #0000ff;\">this</span><span style=\"color: #000000;\">.name\n    }\n\n    get _name() {\n        </span><span style=\"color: #0000ff;\">return</span> <span style=\"color: #0000ff;\">this</span><span style=\"color: #000000;\">.name\n    }\n\n    setName(val: string) {\n        </span><span style=\"color: #0000ff;\">this</span>.name =<span style=\"color: #000000;\"> val\n    }\n\n    set _name(val: string) {\n        </span><span style=\"color: #0000ff;\">this</span>.name =<span style=\"color: #000000;\"> val\n    }\n\n    getAge() {\n        </span><span style=\"color: #0000ff;\">return</span> <span style=\"color: #0000ff;\">this</span><span style=\"color: #000000;\">.age\n    }\n\n    setAge(val: number) {\n        </span><span style=\"color: #0000ff;\">if</span> (val &gt;= 0<span style=\"color: #000000;\">) {\n            </span><span style=\"color: #0000ff;\">this</span>.age =<span style=\"color: #000000;\"> val\n        }\n    }\n}\n\nconst per </span>= <span style=\"color: #0000ff;\">new</span> Person('Front-end Developer', 'Alan', 11<span style=\"color: #000000;\">)\nconsole.log(per, </span>'per'<span style=\"color: #000000;\">);\nconsole.log(per.getName(), </span>'per.getName()'<span style=\"color: #000000;\">);\nconsole.log(per._name, </span>'per._name'<span style=\"color: #000000;\">);\nper.setName(</span>'Faye'<span style=\"color: #000000;\">)\nconsole.log(per.getName(), </span>'per.getName()'<span style=\"color: #000000;\">);\nper._name </span>= 'Alan Faye'<span style=\"color: #000000;\">;\nconsole.log(per._name, </span>'per._name'<span style=\"color: #000000;\">);\nper.setAge(</span>-30<span style=\"color: #000000;\">);\nconsole.log(per.getAge(), </span>'per.getAge()'<span style=\"color: #000000;\">)\nper.setAge(</span>18<span style=\"color: #000000;\">);\nconsole.log(per.getAge(), </span>'per.getAge()')</pre>\n</div>\n<p>&nbsp;</p>"
    },
    {
      "id": 3,
      "title": "TypeScript - interface 接口",
      "time": "2021-08-06 13:52",
      "type": ["TypeScript","JavaScript"],
      "abstract": "接口用来定义一个类结构, 用来定义一个类中应该包含哪些属性，同时接口也可以当成类型声明去使用; 接口是对类的一个限制; type 不可重复声明同名类型，但是interface可以; 接口可以再定义类的时候，去限制类的结构。接口中的所有属性都不能有实际的值，指定义对象的结构，而不考虑实际值。",
      "content":"<div class=\"cnblogs_code\">\n<pre>(<span style=\"color: #0000ff;\">function</span><span style=\"color: #000000;\"> () {\n    </span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> 描述一个对象类型</span>\n    type myType =<span style=\"color: #000000;\">{\n        name: string,\n        age: number\n    }\n\n    </span><span style=\"color: #008000;\">/*</span><span style=\"color: #008000;\">*\n     * 以上形式可以使用接口来实现，\n     * 接口用来定义一个类结构, 用来定义一个类中应该包含哪些属性，同时接口也可以当成类型声明去使用\n     * 接口是对类的一个限制\n     * type 不可重复声明同名类型，但是interface可以\n     * 接口可以再定义类的时候，去限制类的结构。接口中的所有属性都不能有实际的值，指定义对象的结构，而不考虑实际值\n     </span><span style=\"color: #008000;\">*/</span><span style=\"color: #000000;\">\n    interface myInterface {\n        name: string,\n        age: number,\n        sayHello():</span><span style=\"color: #0000ff;\">void</span><span style=\"color: #000000;\">\n    }\n    interface myInterface {\n        gender: string,\n    }\n\n\n    const obj: myType </span>=<span style=\"color: #000000;\"> {\n        name: </span>'alan'<span style=\"color: #000000;\">,\n        age: </span>18<span style=\"color: #000000;\">,\n    }\n\n    const obj2: myInterface </span>=<span style=\"color: #000000;\"> {\n        name: </span>'ALan'<span style=\"color: #000000;\">,\n        age: </span>18<span style=\"color: #000000;\">,\n        gender: </span>'Male'<span style=\"color: #000000;\">\n    }\n    </span><span style=\"color: #008000;\">/*</span><span style=\"color: #008000;\">*\n     * 定义类的时候，可以使用类去实现一个接口\n     * 实现接口就是使类满足接口的需求\n     * 类中必须存在所有接口中的参数\n     *\n     </span><span style=\"color: #008000;\">*/</span><span style=\"color: #000000;\">\n    class MyClass implements myInterface{\n        age: number;\n        gender: string;\n        name: string;\n\n        constructor(name:string, age:number, gender:string) {\n            </span><span style=\"color: #0000ff;\">this</span>.name =<span style=\"color: #000000;\"> name;\n            </span><span style=\"color: #0000ff;\">this</span>.age =<span style=\"color: #000000;\"> age;\n            </span><span style=\"color: #0000ff;\">this</span>.gender =<span style=\"color: #000000;\"> gender;\n        }\n\n        sayHello(): </span><span style=\"color: #0000ff;\">void</span><span style=\"color: #000000;\"> {\n            console.log(</span>'Hello all'<span style=\"color: #000000;\">)\n        }\n\n    }\n\n\n})</span></pre>\n</div>\n<p>&nbsp;</p>"
    },
    {
      "id": 4,
      "title": "TypeScript - 继承(extends) - 抽象类（abstract）",
      "time": "2021-08-06 11:46",
      "type": ["TypeScript","JavaScript"],
      "abstract": "使用继承后，子类将会继承父类所有的属性和方法: 1. 通过继承可以将多个类中共有的代码卸载一个勒种，这样只需要写一次即可让所有子类都同时有父类中的属性和方法; 2.如果希望在子类中添加一些弗雷中没有的属性或方法，直接加就好; 3.如果在子类中添加了和父类方法名一致的方法，则子类方法会覆盖父类方法, 这种子类覆盖父类方法的形式，称之为 方法重写; abstract 开头的是抽象类; 抽象类和其他区别不大，只是不能用来创建对象; 抽象类专门是让别人继承的的类",
      "content":"<div class=\"cnblogs_code\">\n<pre>(<span style=\"color: #0000ff;\">function</span><span style=\"color: #000000;\"> () {\n    </span><span style=\"color: #008000;\">/*</span><span style=\"color: #008000;\">*\n     * abstract 开头的是抽象类，\n     * 抽象类和其他区别不大，只是不能用来创建对象\n     * 抽象类专门是让别人继承的的类\n     </span><span style=\"color: #008000;\">*/</span><span style=\"color: #000000;\">\n   abstract class Animal {\n        </span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> 需要先定义，才能在constructor中this指向</span>\n<span style=\"color: #000000;\">        name: string;\n        age: number;\n\n        </span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> 构造函数，会在对象创建时调用</span>\n        <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> new Dog() 的时候，就会调用constructor</span>\n<span style=\"color: #000000;\">        constructor(name: string, age: number) {\n            </span><span style=\"color: #008000;\">/*</span><span style=\"color: #008000;\">*\n             * 在实例方法中，this就表示当前的实例\n             * 在构造函数中当前对象就是当前新建的那个对象\n             * 可以通过this指向新建的对象中添加属性\n             </span><span style=\"color: #008000;\">*/</span>\n\n            <span style=\"color: #0000ff;\">this</span>.name =<span style=\"color: #000000;\"> name;\n            </span><span style=\"color: #0000ff;\">this</span>.age =<span style=\"color: #000000;\"> age;\n        }\n\n        </span><span style=\"color: #008000;\">/*</span><span style=\"color: #008000;\">*\n         * 该方法不适用所有动物，所以可以改为抽象方法\n         * 抽象方法使用aabstract开头，没有方法体\n         * 抽象方法只能定义在抽象类中，子类必须对抽象方法进行重写\n         </span><span style=\"color: #008000;\">*/</span>\n        <span style=\"color: #008000;\">/*</span><span style=\"color: #008000;\">sayHello() {\n            console.log(`Dog ${this.name} is barking, woofing...`)\n        }</span><span style=\"color: #008000;\">*/</span><span style=\"color: #000000;\">\n        abstract sayHello():</span><span style=\"color: #0000ff;\">void</span><span style=\"color: #000000;\">;\n    }\n\n    </span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> 定义一个表示够的类</span>\n    <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> 使Dog类继承Animal的属性</span>\n    <span style=\"color: #008000;\">/*</span><span style=\"color: #008000;\">*\n     * Dog extends Animal\n     * 此时Animal被称为父类， Dog被称为子类\n     * 使用继承后，子类将会继承父类所有的属性和方法\n     *  -通过继承可以将多个类中共有的代码卸载一个勒种，这样只需要写一次即可让所有子类都同时有父类中的属性和方法\n     *  -如果希望在子类中添加一些弗雷中没有的属性或方法，直接加就好\n     *  -如果在子类中添加了和父类方法名一致的方法，则子类方法会覆盖父类方法, 这种子类覆盖父类方法的形式，称之为 方法重写\n     </span><span style=\"color: #008000;\">*/</span><span style=\"color: #000000;\">\n    class Dog extends Animal {\n        run() {\n            console.log(`${</span><span style=\"color: #0000ff;\">this</span><span style=\"color: #000000;\">.name} is running...`)\n        }\n        sayHello(){\n            console.log(`Dog ${</span><span style=\"color: #0000ff;\">this</span><span style=\"color: #000000;\">.name} is barking, woofing...`)\n        }\n    }\n\n    class Cat extends Animal {\n        sayHello() {\n            console.log(`Cat ${</span><span style=\"color: #0000ff;\">this</span><span style=\"color: #000000;\">.name} is miao....`)\n        }\n    }\n\n\n    const dog </span>= <span style=\"color: #0000ff;\">new</span> Dog('Tom', 4<span style=\"color: #000000;\">);\n    const cat </span>= <span style=\"color: #0000ff;\">new</span> Cat('Max', 3<span style=\"color: #000000;\">);\n    console.log(dog);\n    dog.sayHello();\n    dog.run();\n    cat.sayHello();\n})()</span></pre>\n</div>\n<p>&nbsp;</p>"
    },
    {
      "id": 5,
      "title": "TypeScript - 构造函数 constructor",
      "time": "2021-08-06 10:36",
      "type": ["TypeScript","JavaScript"],
      "abstract": "构造函数 ，是一种特殊的方法。主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。而TypeScript的构造函数用关键字constructor来实现。可以通过this（和java/C#一样代表对象实例的成员访问）关键字来访问当前类体中的属性和方法。",
      "content":"<div class=\"cnblogs_code\">\n<pre><span style=\"color: #000000;\">class Dog {\n    </span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> 需要先定义，才能在constructor中this指向</span>\n<span style=\"color: #000000;\">    name: string;\n    age: number;\n\n    </span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> 构造函数，会在对象创建时调用</span>\n    <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> new Dog() 的时候，就会调用constructor</span>\n<span style=\"color: #000000;\">    constructor(name:string, age:number) {\n        </span><span style=\"color: #008000;\">/*</span><span style=\"color: #008000;\">*\n         * 在实例方法中，this就表示当前的实例\n         * 在构造函数中当前对象就是当前新建的那个对象\n         * 可以通过this指向新建的对象中添加属性\n         </span><span style=\"color: #008000;\">*/</span>\n\n        <span style=\"color: #0000ff;\">this</span>.name =<span style=\"color: #000000;\"> name;\n        </span><span style=\"color: #0000ff;\">this</span>.age =<span style=\"color: #000000;\"> age;\n    }\n    bark(){\n        console.log(</span><span style=\"color: #0000ff;\">this</span>.name + \" is barking, woofing \"<span style=\"color: #000000;\">)\n    }\n}\nconst dog </span>= <span style=\"color: #0000ff;\">new</span> Dog('Tom', 4<span style=\"color: #000000;\">);\nconsole.log(dog);\nconst dog2 </span>= <span style=\"color: #0000ff;\">new</span> Dog('Max', 2<span style=\"color: #000000;\">);\nconsole.log(dog2);\ndog2.bark();</span></pre>\n</div>\n<p>&nbsp;</p>\n<pre><span style=\"color: #f92672;\">class </span>Dog {<br />    <span style=\"color: #75715e;\">// </span><span style=\"color: #75715e; font-family: '宋体',monospace;\">需要先定义，才能在</span><span style=\"color: #75715e;\">constructor</span><span style=\"color: #75715e; font-family: '宋体',monospace;\">中</span><span style=\"color: #75715e;\">this</span><span style=\"color: #75715e; font-family: '宋体',monospace;\">指向<br /></span>name<span style=\"color: #f92672;\">: string</span>;<br />    age<span style=\"color: #f92672;\">: number</span>;<br /><br />    <span style=\"color: #75715e;\">// </span><span style=\"color: #75715e; font-family: '宋体',monospace;\">构造函数，会在对象创建时调用<br /></span><span style=\"color: #75715e;\">// new Dog() </span><span style=\"color: #75715e; font-family: '宋体',monospace;\">的时候，就会调用</span><span style=\"color: #75715e;\">constructor<br /></span><span style=\"color: #f92672;\">constructor</span>(<span style=\"color: #fd971f; font-style: italic;\">name</span><span style=\"color: #f92672;\">:string</span>, <span style=\"color: #fd971f; font-style: italic;\">age</span><span style=\"color: #f92672;\">:number</span>) {<br />        <span style=\"color: #75715e;\">/**<br /></span><span style=\"color: #75715e;\">         * </span><span style=\"color: #75715e; font-family: '宋体',monospace;\">在实例方法中，</span><span style=\"color: #75715e;\">this</span><span style=\"color: #75715e; font-family: '宋体',monospace;\">就表示当前的实例<br /></span><span style=\"color: #75715e;\">* </span><span style=\"color: #75715e; font-family: '宋体',monospace;\">在构造函数中当前对象就是当前新建的那个对象<br /></span><span style=\"color: #75715e;\">* </span><span style=\"color: #75715e; font-family: '宋体',monospace;\">可以通过</span><span style=\"color: #75715e;\">this</span><span style=\"color: #75715e; font-family: '宋体',monospace;\">指向新建的对象中添加属性<br /></span><span style=\"color: #75715e;\">*/<br /></span><span style=\"color: #75715e;\"><br /></span><span style=\"color: #f92672;\">this</span>.name <span style=\"color: #f92672;\">= </span><span style=\"color: #fd971f; font-style: italic;\">name</span>;<br />        <span style=\"color: #f92672;\">this</span>.age <span style=\"color: #f92672;\">= </span><span style=\"color: #fd971f; font-style: italic;\">age</span>;<br />    }<br />    <span style=\"color: #a6e22e;\">bark</span>(){<br />        <span style=\"font-style: italic;\">console</span>.<span style=\"color: #a6e22e;\">log</span>(<span style=\"color: #f92672;\">this</span>.name <span style=\"color: #f92672;\">+ </span><span style=\"color: #e6db74;\">\" is barking, woofing \"</span>)<br />    }<br />}<br /><span style=\"color: #f92672;\">const </span><span style=\"font-style: italic;\">dog </span><span style=\"color: #f92672;\">= new </span>Dog(<span style=\"color: #e6db74;\">'Tom'</span>, <span style=\"color: #ae81ff;\">4</span>);<br /><span style=\"font-style: italic;\">console</span>.<span style=\"color: #a6e22e;\">log</span>(<span style=\"font-style: italic;\">dog</span>);<br /><span style=\"color: #f92672;\">const </span><span style=\"font-style: italic;\">dog2 </span><span style=\"color: #f92672;\">= new </span>Dog(<span style=\"color: #e6db74;\">'Max'</span>, <span style=\"color: #ae81ff;\">2</span>);<br /><span style=\"font-style: italic;\">console</span>.<span style=\"color: #a6e22e;\">log</span>(<span style=\"font-style: italic;\">dog2</span>);<br /><span style=\"font-style: italic;\">dog2</span>.<span style=\"color: #a6e22e;\">bark</span>();</pre>"
    },
    {
      "id": 6,
      "title": "TypeScript - Class 类",
      "time": "2021-08-23 14:11",
      "type": ["TypeScript","JavaScript"],
      "abstract": "TypeScript 是面向对象的 JavaScript。类描述了所创建的对象共同的属性和方法。TypeScript 支持面向对象的所有特性，比如 类、接口等。",
      "content":"<div class=\"cnblogs_code\">\n<pre><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> 使用class类关键词来定义一个类</span><span style=\"color: #008000;\">\n/*</span><span style=\"color: #008000;\">*\n *  对象中主要包含两个部分\n *  属性\n *  方法\n </span><span style=\"color: #008000;\">*/</span><span style=\"color: #000000;\">\nclass Person{\n    </span><span style=\"color: #008000;\">/*</span><span style=\"color: #008000;\">*\n     * 直接定义的属性是实例属性， 需要通过对象的实力去访问；\n     * const per = new Persion();\n     * per.name\n     </span><span style=\"color: #008000;\">*/</span><span style=\"color: #000000;\">\n\n    name: string </span>= 'Alan'<span style=\"color: #000000;\">;\n\n    </span><span style=\"color: #008000;\">/*</span><span style=\"color: #008000;\">*\n     * 使用static开头的属性是静态属性（类属性），无需创建对象，可以直接通过类访问。\n     * Persion.age\n     </span><span style=\"color: #008000;\">*/</span><span style=\"color: #000000;\">\n   static age: number </span>= 18<span style=\"color: #000000;\">;\n\n    </span><span style=\"color: #008000;\">/*</span><span style=\"color: #008000;\">*\n     * readonly 标识只读属性，不能修改\n     </span><span style=\"color: #008000;\">*/</span><span style=\"color: #000000;\">\n    readonly sex: string </span>= 'male'<span style=\"color: #000000;\">;\n\n    </span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> 定义方法</span>\n    <span style=\"color: #008000;\">/*</span><span style=\"color: #008000;\">*\n     * 如果方法以static开头，则方法是类方法，可以直接通过雷区调用\n     </span><span style=\"color: #008000;\">*/</span><span style=\"color: #000000;\">\n    sayHello(){\n        console.log(</span>\"Hello\"<span style=\"color: #000000;\">)\n    }\n    static sayHelloWorld(){\n        console.log(</span>\"Hello world\"<span style=\"color: #000000;\">)\n    }\n\n\n}\n\n\nconst per </span>= <span style=\"color: #0000ff;\">new</span><span style=\"color: #000000;\"> Person();\n\nconsole.log(per, </span>'per'<span style=\"color: #000000;\">)\nconsole.log(per.name);\n</span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> console.log(per.name, per.age);</span>\n<span style=\"color: #000000;\">console.log(Person.age);\n\nper.name </span>= 'Faye'; <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> 实例属性可直接修改</span>\n<span style=\"color: #000000;\">console.log(per.name);\n\n</span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> per.sex = 'Faye'; // 报错</span>\n<span style=\"color: #000000;\">console.log(per.sex);\n\n\nper.sayHello();\nPerson.sayHelloWorld();</span></pre>\n</div>\n<p>&nbsp;</p>"
    },
    {
      "id": 7,
      "title": "TypeScript - 配置文件 tsconfig.json",
      "time": "2021-08-03 14:59",
      "type": ["TypeScript","JavaScript"],
      "abstract": "TypeScript 使用 tsconfig.json 文件作为其配置文件，当一个目录中存在 tsconfig.json 文件，则认为该目录为 TypeScript 项目的根目录。通常 tsconfig.json 文件主要包含两部分内容：指定待编译文件和定义编译选项。",
      "content":"<h5 id=\"tsconfigjson-文件的生成\"><code><code>tsconfig.json</code>&nbsp;文件</code></h5>\n<p>创建两种方式:</p>\n<p>1. 直接在根目录新建tsconfig.config.json (配置文件需要自己配置)</p>\n<p>2. 执行tsc --init&nbsp; (会自动创建相关配置)</p>\n<pre><code class=\"hljs language-csharp\">tsc --<span class=\"hljs-keyword\">init</span></code></pre>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: #000000;\">{\n  </span>\"compilerOptions\"<span style=\"color: #000000;\">: {\n    </span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> target 用来指定ts被编译为的ES版本</span>\n    <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> '--target' option must be: 'es3', 'es5', 'es6', 'es2015', 'es2016', 'es2017', 'es2018', 'es2019', 'es2020', 'es2021', 'esnext'.</span>\n    \"target\": \"ES6\"<span style=\"color: #000000;\">,\n    </span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> 指定要使用的模块化的规范</span>\n    <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> '--module' option must be: 'none', 'commonjs', 'amd', 'system', 'umd', 'es6', 'es2015', 'es2020', 'esnext'.</span>\n    \"module\": \"System\"<span style=\"color: #000000;\">,\n    </span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> library 用来指定项目中要使用的库</span>\n    <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> 代码提示</span>\n    <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> '--lib' option must be: 'es5', 'es6', 'es2015', 'es7', 'es2016', 'es2017', 'es2018', 'es2019', 'es2020', 'es2021', 'esnext', 'dom', 'dom.iterable', 'webworker', 'webworker.importscripts', 'webworker.iterable', 'scripthost', 'es2015.core', 'es2015.collection', 'es2015.generator', 'es2015.iterable', 'es2015.promise', 'es2015.proxy', 'es2015.reflect', 'es2015.symbol', 'es2015.symbol.wellknown', 'es2016.array.include', 'es2017.object', 'es2017.sharedmemory', 'es2017.string', 'es2017.intl', 'es2017.typedarrays', 'es2018.asyncgenerator', 'es2018.asynciterable', 'es2018.intl','es2018.promise', 'es2018.regexp', 'es2019.array', 'es2019.object', 'es2019.string', 'es2019.symbol', 'es2020.bigint', 'es2020.promise', 'es2020.sharedmemory', 'es202.string', 'es2020.symbol.wellknown', 'es2020.intl', 'es2021.promise', 'es2021.string', 'es2021.weakref', 'esnext.array', 'esnext.symbol', 'esnext.asynciterable', 'esnext.intl','esnext.bigint', 'esnext.string', 'esnext.promise', 'esnext.weakref'.</span>\n    <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> \"lib\": ['dom']</span>\n\n    <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> outDir 用来指定编译后文件所在的目录</span>\n    \"outDir\": \"./dist\"<span style=\"color: #000000;\">,\n\n    </span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> outFile 将代码合并为一个文件</span>\n    <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> 设置outFile后，所有全局作用域中的代码 会合并到同一个文件， 但是如果文件中有模块引用，则module需要改为System</span>\n    <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> 该功能一般是打包工具来做，仅作了解，</span>\n    \"outFile\": \"./dist/app.js\"<span style=\"color: #000000;\">,\n\n    </span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> 是否编辑js文件， 默认false</span>\n    \"allowJs\": <span style=\"color: #0000ff;\">true</span><span style=\"color: #000000;\">,\n    </span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> 是否检查js代码是否符合语法规范</span>\n    <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> js中， let a = 10; a = 'hello'; true的情况下，会变检查</span>\n    \"checkJs\": <span style=\"color: #0000ff;\">true</span><span style=\"color: #000000;\">,\n\n    </span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> 是否移除注释</span>\n    \"removeComments\": <span style=\"color: #0000ff;\">true</span><span style=\"color: #000000;\">,\n\n    </span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> 不生成编译后的文件 即dist内的东西</span>\n    \"noEmit\": <span style=\"color: #0000ff;\">false</span><span style=\"color: #000000;\">,\n\n    </span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> 当有错误的时候，是否生成编译文件，避免编译错误代码</span>\n    \"noEmitOnError\": <span style=\"color: #0000ff;\">true</span><span style=\"color: #000000;\">,\n\n    </span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> 语法检查相关属性</span>\n\n    <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> 所有严格检查的总开关， 下面的一些是否启动，即使后面的是true， 如果此处是false，同样不执行</span>\n    \"strict\": <span style=\"color: #0000ff;\">true</span><span style=\"color: #000000;\">,\n\n    </span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> 用来设置编译后的文件是否启用严格模式，默认false</span>\n    \"alwaysStrict\": <span style=\"color: #0000ff;\">true</span><span style=\"color: #000000;\">,\n\n    </span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> 否否允许隐式的any类型</span>\n    <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> function sum(a, b){ return a + b } 此处a b就是隐式的any</span>\n    \"noImplicitAny\": <span style=\"color: #0000ff;\">true</span><span style=\"color: #000000;\">,\n\n    </span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">不允许不明确类型的this</span>\n    <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> function a(){ console.log(this) }</span>\n    \"noImplicitThis\": <span style=\"color: #0000ff;\">true</span><span style=\"color: #000000;\">,\n\n    </span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> 是否检测null值</span>\n    \"strictNullChecks\": <span style=\"color: #0000ff;\">true</span><span style=\"color: #000000;\">\n  }\n}\n </span></pre>\n</div>\n<p>&nbsp;</p>"
    },
    {
      "id": 8,
      "title": "TypeScript - 安装，类型",
      "time": "@ 2021-08-03 14:59",
      "type": ["TypeScript","JavaScript"],
      "abstract": "要使用typescript需要全局安装 通过tsc -v 来验证是否安装成功; 类型都要小写，类型有 number, string, boolean, object, any(任意类型), unknown(类型安全的any), void(空置 undefined), never(没有值), array, tuple(TS新增类型，固定长度的数组), enum(TS新增类型, 枚举类型)",
      "content":"<div class=\"cnblogs_code\">\n<pre><span style=\"color: #008000;\">// 要使用typescript需要全局安装 通过tsc -v 来验证是否安装成功</span></pre>\n<pre>npm i -g typescript<br /><br /><span style=\"color: #008000;\"><br /><br />//</span><span style=\"color: #008000;\"> ts 文件中完全可以写js语法， 完全兼容js</span><span style=\"color: #008000;\">\n//</span><span style=\"color: #008000;\"> ts 本身在运行时，会转化为js文件，从而执行</span><span style=\"color: #008000;\">\n//</span><span style=\"color: #008000;\"> ts 可以在定义变量的时候，确认他的类型，防止赋予不同类型的值</span>\n\n<span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> 类型都要小写</span><span style=\"color: #008000;\">\n/*</span><span style=\"color: #008000;\">*\n 类型有 number, string, boolean, object, any(任意类型), unknown(类型安全的any), void(空置 undefined), never(没有值), array, tuple(TS新增类型，固定长度的数组), enum(TS新增类型, 枚举类型)\n*</span><span style=\"color: #008000;\">*/</span>\n<span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> 声明一个变量，同时指定类型为number</span>\n<span style=\"color: #000000;\">let a : number;\n\n</span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> 因为a类型已设置，所以只能赋值数字</span>\na = 10<span style=\"color: #000000;\">;\na </span>= 20<span style=\"color: #000000;\">;\n</span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> a = 'hellow' //因为类型不是number，所以会报错</span>\n\n<span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> 声明完变量直接赋值</span>\nlet b : <span style=\"color: #0000ff;\">boolean</span> = <span style=\"color: #0000ff;\">false</span><span style=\"color: #000000;\">;\n\n</span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> js中函数是不考虑参数的类型和个数</span>\n<span style=\"color: #0000ff;\">function</span><span style=\"color: #000000;\"> sum(a, b){\n    </span><span style=\"color: #0000ff;\">return</span> a +<span style=\"color: #000000;\"> b;\n}\n\nconsole.log(sum(</span>123, 456)); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> 579</span>\nconsole.log(sum(123, '456')); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> '123456'</span>\n\n<span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> ts 参数可以增加类型，同时函数本身的返回值也可以定义类型</span>\n<span style=\"color: #0000ff;\">function</span><span style=\"color: #000000;\"> sum_(a: number, b: number): number{\n    </span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> return a + b + 'hello;  // 报错</span>\n    <span style=\"color: #0000ff;\">return</span> a +<span style=\"color: #000000;\"> b;\n}\n\nconsole.log(sum_(</span>123, 456)); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> 579</span><span style=\"color: #008000;\">\n//</span><span style=\"color: #008000;\"> console.log(sum_(123, '456')); // 报错  Argument of type 'string' is not assignable to parameter of type 'number'</span>\n\n\n<span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> object 标记JS对象， 在ts中不实用，因为 对象是对象， 方法还是对象， 对象太多了，没做太多限制</span><span style=\"color: #008000;\">\n/*</span><span style=\"color: #008000;\">*\n {} 用来指定对象中可以包含的属性\n 语法: {key: value, key: value}\n 在属性名后增加？， 表示属性是可选的， 可以不用赋值\n *</span><span style=\"color: #008000;\">*/</span>\n<span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> 所以一般如下实用</span>\nlet c : {name: string}; <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> 有且只有一个属性</span><span style=\"color: #008000;\">\n//</span><span style=\"color: #008000;\"> c = {}; // 报错，未定义name</span>\nc = {name: 'Alan'<span style=\"color: #000000;\">}\n</span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> c = {name: 'Alan', age: 18}  // 报错，因为没有定义age属性，所以c定义的时候，可以固定对象的结构，key值</span><span style=\"color: #008000;\">\n//</span><span style=\"color: #008000;\"> 同时，在属性名后增加？， 表示属性是可选的， 可以不用赋值</span>\nlet d : {name: string, age?: number}; <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> name 强制，age可选</span>\nd = {name: 'Alan'<span style=\"color: #000000;\">};\nd </span>= {name: 'Alan', age: 12<span style=\"color: #000000;\">};\n\n</span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> 如果想要不限制任意属性，则需要 增加任意类型的属性</span>\nlet e : {name: string, [propName: string]: any}; <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> propName不固定，可随意写</span>\ne = {name: 'Alan', age: 18, dob: 19901120<span style=\"color: #000000;\">}\n\n</span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> 通过箭头函数，来设置函数结构的类型声明</span><span style=\"color: #008000;\">\n//</span><span style=\"color: #008000;\"> 语法： (形参: 类型， 形参: 类型 ...) =&gt; 返回值</span>\nlet f:(a: number, b:number) =&gt;<span style=\"color: #000000;\"> number;\nf </span>= <span style=\"color: #0000ff;\">function</span> (n1, n2):number {  <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> 如果在此处定义n1为不是number的类型，则同样会报错</span>\n    <span style=\"color: #0000ff;\">return</span> n1 +<span style=\"color: #000000;\"> n2;\n}\n\n</span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> 数组类型</span><span style=\"color: #008000;\">\n//</span><span style=\"color: #008000;\"> string [] 字符串数组</span><span style=\"color: #008000;\">\n//</span><span style=\"color: #008000;\"> number [] 数字数组  or Array&lt;number&gt;</span><span style=\"color: #008000;\">\n//</span><span style=\"color: #008000;\"> any [], Array&lt;any&gt; 任意数组，但是不建议用any</span>\n\n\n<span style=\"color: #008000;\">/*</span><span style=\"color: #008000;\">*\n * tuple 元组 固定长度的数组\n * 长度固定后，储存效率高，变化几率小一点\n * 语法： [类型， 类型， 类型] 不会太多，太多直接用数组\n </span><span style=\"color: #008000;\">*/</span><span style=\"color: #000000;\">\nlet h: [string, string, number];\nh </span>= ['hello', 'word', 123<span style=\"color: #000000;\">];\n\n\n</span><span style=\"color: #008000;\">/*</span><span style=\"color: #008000;\">*\n * enum 枚举\n *\n </span><span style=\"color: #008000;\">*/</span><span style=\"color: #000000;\">\n\nenum Gender {\n    Male, </span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> Male = 0,</span>\n    Female, <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> Female = 1,</span>\n<span style=\"color: #000000;\">}\n\nlet i: {name: string, gender:Gender}\ni </span>= {name: 'Alan'<span style=\"color: #000000;\">, gender: Gender.Male};\n\nconsole.log(i.gender </span>===<span style=\"color: #000000;\"> Gender.Male);\n\n</span><span style=\"color: #008000;\">/*</span><span style=\"color: #008000;\">*\n * &amp; 表示同时\n </span><span style=\"color: #008000;\">*/</span><span style=\"color: #000000;\">\nlet j: {name: string} </span>&amp;<span style=\"color: #000000;\"> {age: number};\nj </span>= {name: 'Alan', age: 18} <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> 必须存在两个属性</span>\n\n<span style=\"color: #008000;\">/*</span><span style=\"color: #008000;\">*\n * 类型的别名.\n * 简化类型\n </span><span style=\"color: #008000;\">*/</span><span style=\"color: #000000;\">\ntype myType </span>= 1 | 2 | 3 | 4 | 5<span style=\"color: #000000;\">;\nlet k: </span>1 | 2 | 3 | 4 | 5<span style=\"color: #000000;\">;\nlet l: myType;\nlet m: myType;\nk </span>= 5<span style=\"color: #000000;\">;\nk </span>= 3;</pre>\n</div>\n<p>&nbsp;</p>"
    },
    {
      "id": 9 ,
      "title": "ES6 - Class - 继承",
      "time": "2021-03-01 22:46",
      "type": ["ES6","JavaScript"],
      "abstract": "Class 其实是一个语法糖，他能实现的，ES5同样能实现",
      "content":"<p>Class 其实是一个语法糖，他能实现的，ES5同样能实现</p>\n<p>&nbsp;</p>\n<p>ES5</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: #008000;\">　　//</span><span style=\"color: #008000;\">手机</span>\n<span style=\"color: #000000;\">    function Phone(brand,price){\n        </span><span style=\"color: #0000ff;\">this</span>.brand =<span style=\"color: #000000;\"> brand;\n        </span><span style=\"color: #0000ff;\">this</span>.price =<span style=\"color: #000000;\"> price;\n    }\n    </span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">添加方法</span>\n    Phone.prototype.call =<span style=\"color: #000000;\"> function(){\n        console.log(</span><span style=\"color: #800000;\">\"</span><span style=\"color: #800000;\">I can call someone</span><span style=\"color: #800000;\">\"</span><span style=\"color: #000000;\">)\n    }\n    </span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">实例化对象</span>\n    let Huawei = <span style=\"color: #0000ff;\">new</span> Phone(<span style=\"color: #800000;\">\"</span><span style=\"color: #800000;\">华为</span><span style=\"color: #800000;\">\"</span>,<span style=\"color: #800080;\">4999</span><span style=\"color: #000000;\">);\n    Huawei.call();\n    console.log(Huawei); <br /></span></pre>\n<pre>    //I can call someone     Phone {brand: \"小米\", price: 4999} obj</pre>\n<pre><span style=\"color: #000000;\">&nbsp;</span></pre>\n</div>\n<p>&nbsp;</p>\n<p>ES6</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: #000000;\"> 　　class Phone{<br />　　　　　brand: string;<br />　　　　　price: number;　<br />\n        </span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">构造方法， 名字不能修改</span>\n<span style=\"color: #000000;\">        constructor(brand,price) {\n            </span><span style=\"color: #0000ff;\">this</span>.brand =<span style=\"color: #000000;\"> brand;\n            </span><span style=\"color: #0000ff;\">this</span>.price =<span style=\"color: #000000;\"> price;\n        }\n\n        </span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">方法必须使用该语法，不能使用ES5的对象完整形式</span>\n<span style=\"color: #000000;\">        call(){\n            console.log(</span>\"I can call someone\"<span style=\"color: #000000;\">)\n        }\n    }\n    let Xiaomi </span>= <span style=\"color: #0000ff;\">new</span> Phone(\"小米\", 4999<span style=\"color: #000000;\">);\n    Xiaomi.call();\n    console.log(Xiaomi);\n    </span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">I can call someone     Phone {brand: \"小米\", price: 4999} obj</span></pre>\n</div>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<h1>继承</h1>\n<p>ES5 实现继承</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">手机</span>\n    <span style=\"color: #0000ff;\">function</span><span style=\"color: #000000;\"> Phone(brand, price) {\n        </span><span style=\"color: #0000ff;\">this</span>.brand =<span style=\"color: #000000;\"> brand;\n        </span><span style=\"color: #0000ff;\">this</span>.price =<span style=\"color: #000000;\"> price;\n    }\n\n    </span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">添加方法</span>\n    Phone.prototype.call = <span style=\"color: #0000ff;\">function</span><span style=\"color: #000000;\"> () {\n        console.log(</span>\"I can call someone\"<span style=\"color: #000000;\">)\n    }\n\n    </span><span style=\"color: #0000ff;\">function</span><span style=\"color: #000000;\"> SmartPhone(brand, price, color, size) {\n        Phone.call(</span><span style=\"color: #0000ff;\">this</span>, brand, price); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">此处为了继承phone， 用call修改this指向，并传入参数</span>\n        <span style=\"color: #0000ff;\">this</span>.color =<span style=\"color: #000000;\"> color;\n        </span><span style=\"color: #0000ff;\">this</span>.size =<span style=\"color: #000000;\"> size;\n    }\n\n    </span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">设置子级构造函数的原型</span>\n    SmartPhone.prototype = <span style=\"color: #0000ff;\">new</span><span style=\"color: #000000;\"> Phone;\n    SmartPhone.prototype.constructor </span>=<span style=\"color: #000000;\"> SmartPhone;\n\n    </span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">声明子类的方法</span>\n    SmartPhone.prototype.photo = <span style=\"color: #0000ff;\">function</span><span style=\"color: #000000;\"> () {\n        console.log(</span>\"I can take phone\"<span style=\"color: #000000;\">);\n    }\n\n    SmartPhone.prototype.playGame </span>= <span style=\"color: #0000ff;\">function</span><span style=\"color: #000000;\"> () {\n        console.log(</span>\"I can play games\"<span style=\"color: #000000;\">);\n    }\n\n    const xiaomi </span>= <span style=\"color: #0000ff;\">new</span> SmartPhone(\"小米\", 3999, '黑色', '5.5inch'<span style=\"color: #000000;\">);\n    console.log(xiaomi)<br /><img src=\"https://img2020.cnblogs.com/blog/1553313/202103/1553313-20210302095236698-1069026905.png\" alt=\"\" loading=\"lazy\" /></span></pre>\n<p>&nbsp;</p>\n<pre></pre>\n<p>&nbsp;</p>\n</div>\n<p>&nbsp;</p>\n<p>ES6</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: #000000;\">class Phone{\n        </span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">构造方法， 名字不能修改</span>\n<span style=\"color: #000000;\">        constructor(brand,price) {\n            </span><span style=\"color: #0000ff;\">this</span>.brand =<span style=\"color: #000000;\"> brand;\n            </span><span style=\"color: #0000ff;\">this</span>.price =<span style=\"color: #000000;\"> price;\n        }\n\n        </span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">方法必须使用该语法，不能使用ES5的对象完整形式</span>\n<span style=\"color: #000000;\">        call(){\n            console.log(</span>\"I can call someone\"<span style=\"color: #000000;\">)\n        }\n    }\n\n    class SmartPhone extends Phone { </span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">使用extends来继承<br /></span></pre>\n<pre><span>        brand: string;<br />　　　　　price: number;　</span></pre>\n<pre><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">构造方法， 名字不能修改</span> <span style=\"color: #000000;\"> constructor(brand, price, color, size) { super(brand,price);</span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">类似与 Phone.call(this, brand, price);</span> <span style=\"color: #0000ff;\">this</span>.color =<span style=\"color: #000000;\"> color; </span><span style=\"color: #0000ff;\">this</span>.size =<span style=\"color: #000000;\"> size; } </span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">方法必须使用该语法，不能使用ES5的对象完整形式</span> <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">声明子类的方法</span> <span style=\"color: #000000;\"> photo() { console.log(</span>\"I can take phone\"<span style=\"color: #000000;\">); } playGame() { console.log(</span>\"I can play games\"<span style=\"color: #000000;\">); } } const xiaomi </span>= <span style=\"color: #0000ff;\">new</span> SmartPhone(\"小米\", 3999, '黑色', '5.5inch'<span style=\"color: #000000;\">); console.log(xiaomi);<br /></span></pre>\n<pre>　　xiaomi.call();<br />　　xiaomi.photo();<br />　　xiaomi.playGame();</pre>\n<pre><span style=\"color: #000000;\"><br /><img src=\"https://img2020.cnblogs.com/blog/1553313/202103/1553313-20210302095434442-763103722.png\" alt=\"\" loading=\"lazy\" /></span></pre>\n</div>\n<p>&nbsp;</p>\n<p>同时子类可以复写父类的方法</p>\n<p>&nbsp;</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: #000000;\">class Phone{<br /></span></pre>\n<pre><span>        brand: string;<br />　　　　　price: number;　</span></pre>\n<pre><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">构造方法， 名字不能修改</span> <span style=\"color: #000000;\"> constructor(brand,price) { </span><span style=\"color: #0000ff;\">this</span>.brand =<span style=\"color: #000000;\"> brand; </span><span style=\"color: #0000ff;\">this</span>.price =<span style=\"color: #000000;\"> price; } </span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">方法必须使用该语法，不能使用ES5的对象完整形式</span> <span style=\"color: #000000;\"> call(){ console.log(</span>\"I can call someone\"<span style=\"color: #000000;\">) } } class SmartPhone extends Phone { </span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">使用extends来继承</span> <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">构造方法， 名字不能修改</span> <span style=\"color: #000000;\"> constructor(brand, price, color, size) { super(brand,price);</span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">类似与 Phone.call(this, brand, price);</span> <span style=\"color: #0000ff;\">this</span>.color =<span style=\"color: #000000;\"> color; </span><span style=\"color: #0000ff;\">this</span>.size =<span style=\"color: #000000;\"> size; } </span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">方法必须使用该语法，不能使用ES5的对象完整形式</span> <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">声明子类的方法</span> photo = <span style=\"color: #0000ff;\">function</span><span style=\"color: #000000;\"> () { console.log(</span>\"I can take phone\"<span style=\"color: #000000;\">); } playGame </span>= <span style=\"color: #0000ff;\">function</span><span style=\"color: #000000;\"> () { console.log(</span>\"I can play games\"<span style=\"color: #000000;\">); } <span style=\"color: #ff0000;\">call(){ console.log(</span></span><span style=\"color: #ff0000;\">\"I can make a video call\"</span><span style=\"color: #000000;\"><span style=\"color: #ff0000;\">); }</span> } const xiaomi </span>= <span style=\"color: #0000ff;\">new</span> SmartPhone(\"小米\", 3999, '黑色', '5.5inch'<span style=\"color: #000000;\">); console.log(xiaomi) xiaomi.call(); xiaomi.photo(); xiaomi.playGame();<br /><img src=\"https://img2020.cnblogs.com/blog/1553313/202103/1553313-20210302095825125-1314978548.png\" alt=\"\" loading=\"lazy\" /></span></pre>\n<p>&nbsp;</p>\n<pre></pre>\n<p>&nbsp;</p>\n<pre><span style=\"color: #000000;\">&nbsp;</span></pre>\n</div>\n<p>&nbsp;</p>"
    },
    {
      "id": 10,
      "title": "ES6 - Promise",
      "time": "2021-03-01 22:15",
      "type": ["ES6","JavaScript"],
      "abstract": "是异步编程的一种解决方案。 从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。",
      "content":"<p>Promise 实例化</p>\n<div class=\"cnblogs_code\">\n<pre>const P = <span style=\"color: #0000ff;\">new</span> Promise(<span style=\"color: #0000ff;\">function</span><span style=\"color: #000000;\">(resolve, reject){\n\n　　setTimeout(</span><span style=\"color: #0000ff;\">function</span><span style=\"color: #000000;\">(){\n\n　　　　//let data </span>= '数据读取成功'<span style=\"color: #000000;\">;\n\n　　　　//resolve(data);//将成功函数赋予resolve属性\n\n　　　　let  err </span>= \" 数据读取失败\"<span style=\"color: #000000;\">\n\n　　　　reject(err);</span>//将失败函数赋予resolve属性</pre>\n<pre><span style=\"color: #000000;\">　　},</span>1000<span style=\"color: #000000;\">)<br />}<br />//测试的情况下，用那个，显示哪个，目前代码是激活失败状态</span></pre>\n</div>\n<p>&nbsp;</p>\n<p>调用promise对象 的then方法, 从而实现坚挺成功失败</p>\n<div class=\"cnblogs_code\">\n<pre>P.then(<span style=\"color: #0000ff;\">function</span><span style=\"color: #000000;\">(value){\n\n　　console.log(value)\n\n},</span><span style=\"color: #0000ff;\">function</span><span style=\"color: #000000;\">(error){\n\n　　console.log(error)<br />　　console.error(error)\n\n})</span></pre>\n</div>\n<p>&nbsp;</p>\n<p>promise 封装ajax</p>\n<p>&nbsp;</p>\n<div class=\"cnblogs_code\">\n<pre>const url = 'https://api.apiopen.top/getJoke'<span style=\"color: #000000;\">\n    const ajax </span>= <span style=\"color: #0000ff;\">new</span> Promise((resolve,reject) =&gt;<span style=\"color: #000000;\"> {\n        </span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">1. 创建对象</span>\n        const xhr = <span style=\"color: #0000ff;\">new</span><span style=\"color: #000000;\"> XMLHttpRequest();\n        </span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">2. 初始化</span>\n        xhr.open(\"GET\"<span style=\"color: #000000;\">,url);\n        </span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">3. 发送</span>\n<span style=\"color: #000000;\">        xhr.send();\n        </span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">4. 绑定时间，处理相应结果</span>\n        xhr.onreadystatechange = <span style=\"color: #0000ff;\">function</span><span style=\"color: #000000;\">(){\n            </span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">判断结果状态</span>\n            <span style=\"color: #0000ff;\">if</span>(xhr.readyState === 4<span style=\"color: #000000;\">){\n                </span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">判断响应状态吗200-290</span>\n                <span style=\"color: #0000ff;\">if</span>(xhr.status &gt;=200 &amp;&amp; xhr.status&lt;300<span style=\"color: #000000;\">){\n                    </span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">成功回调</span>\n<span style=\"color: #000000;\">                    resolve(xhr.response);\n                }\n                </span><span style=\"color: #0000ff;\">else</span><span style=\"color: #000000;\">{\n                    </span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">失败回调</span>\n<span style=\"color: #000000;\">                    reject(xhr.status)\n                }\n            }\n        }\n    });\n    </span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">指定回调</span>\n    ajax.then(<span style=\"color: #0000ff;\">function</span><span style=\"color: #000000;\">(res){\n        console.log(res)\n    },</span><span style=\"color: #0000ff;\">function</span><span style=\"color: #000000;\">(error){\n        console.error(error);\n    })<br /><br /></span></pre>\n<pre>//ES6 写法<br />/*<br />ajax.then(res=&gt;{<br />    console.log(res)<br />},error=&gt;{<br />    console.error(error);<br />})</pre>\n<pre><span style=\"color: #000000;\">   */</span></pre>\n</div>\n<p>&nbsp;</p>"
    },
    {
      "id": 11,
      "title": "ES6 - 扩展运算符 ...",
      "time": "2021-03-01 17:13",
      "type": ["ES6","JavaScript"],
      "abstract": " ... 三个点为 扩展运算符，能将 数组 转化为逗号分隔的 参数序列",
      "content":"<pre> ... 三个点为 扩展运算符，能将 数组 转化为逗号分隔的 参数序列<br /> <br />1. 数组的合并</pre>\n<div class=\"cnblogs_code\">\n<pre>const a = ['1', '2'<span style=\"color: #000000;\">];\nconst b </span>= ['4','5','6'<span style=\"color: #000000;\">];\nconst c1 </span>= a.concat(b); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">ES5需要用数组的concat方法拼接数组</span>\nconst c2 = [...a,...b];</pre>\n</div>\n<pre><br />2. 数组的克隆</pre>\n<div class=\"cnblogs_code\">\n<pre>const a = ['1', '2'<span style=\"color: #000000;\">];\nconst b </span>= [...a]; <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> ['1', '2']<br /><br /></span></pre>\n</div>\n<pre>3. 将为数组转化为真数组</pre>\n<div class=\"cnblogs_code\">\n<pre> const divs = document.querySelectorAll('div'); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> 在console.log中，其原型链显示他是对象object<br /><img src=\"https://img2020.cnblogs.com/blog/1553313/202103/1553313-20210301171422768-355110946.png\" alt=\"\" loading=\"lazy\" /></span></pre>\n<pre></pre>\n<pre> const divArr = [...divs];<span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> 此时就变成了真正的数组<br /><img src=\"https://img2020.cnblogs.com/blog/1553313/202103/1553313-20210301171453692-37423727.png\" alt=\"\" loading=\"lazy\" /></span></pre>\n<p>&nbsp;</p>\n<pre></pre>\n<p>&nbsp;</p>\n<pre><span style=\"color: #008000;\">&nbsp;</span></pre>\n</div>\n<p>&nbsp;</p>"
    },
    {
      "id": 12,
      "title": "ES6 - 参数默认值",
      "time": "2021-03-01 17:13",
      "type": ["ES6","JavaScript"],
      "abstract": "形参初始值， 具有默认值的参数，一般位置要靠后（潜规则）",
      "content":"<pre> 1.形参初始值， 具有默认值的参数，一般位置要靠后（潜规则）<br /><br /></pre>\n<div class=\"cnblogs_code\">\n<pre> <span style=\"color: #0000ff;\">function</span> add(a,b,c=10<span style=\"color: #000000;\">){\n      </span><span style=\"color: #0000ff;\">return</span> a + b +<span style=\"color: #000000;\"> c;\n  }\n  let resutl </span>= add(1,2); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">13</span></pre>\n</div>\n<p>&nbsp;</p>\n<pre><br /><br />2. 与解构赋值结合</pre>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: #0000ff;\">function</span> connect ({host = \"127.0.0.1\"<span style=\"color: #000000;\">,username,password, port}){\n    console.log(host);\n    console.log(username);\n    console.log(password);\n    console.log(port);\n  }\n  connect({\n      username:</span>'root'<span style=\"color: #000000;\">,\n      password:</span>'root'<span style=\"color: #000000;\">,\n      port:</span>'8080'<span style=\"color: #000000;\">\n  })</span></pre>\n</div>\n<p>&nbsp;</p>"
    },
    {
      "id": 13,
      "title": "ES6 - 箭头函数",
      "time": "2021-03-01 13:49",
      "type": ["ES6","JavaScript"],
      "abstract": "箭头函数的目的是 简化函数的定义，语法糖; 一般情况下，最简单的写法就是方法return一个值; 箭头函数表达式的语法比函数表达式更简洁，并且没有自己的this，arguments，super或new.target。箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。",
      "content":"<p><span style=\"font-family: 宋体;\">箭头函数的目的是</span> <span style=\"font-family: 宋体;\">简化函数的定义，语法糖</span></p>\n<p>&nbsp;</p>\n<p><span style=\"font-family: 宋体;\">一般情况下，最简单的写法就是方法return一个值</span></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<div class=\"cnblogs_code\">\n<pre> // ES6 : <br />let f = v =&gt;<span style=\"color: #000000;\"> v;\n<br />//ES5<br />\n  </span><span style=\"color: #0000ff;\">var</span> f = <span style=\"color: #0000ff;\">function</span><span style=\"color: #000000;\">(v){\n\n      </span><span style=\"color: #0000ff;\">return</span><span style=\"color: #000000;\"> v\n\n  }</span></pre>\n</div>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p><span style=\"font-family: 宋体;\">其次就是各种情况应该如何去写箭头函数</span></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">无参数转化</span>\n\n<span style=\"color: #0000ff;\">var</span> f = <span style=\"color: #0000ff;\">function</span><span style=\"color: #000000;\"> (){\n\n      </span><span style=\"color: #0000ff;\">return</span> 123<span style=\"color: #000000;\">\n\n  }\n\n  let f </span>= () =&gt; 123\n\n \n\n<span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">多个参数</span>\n\n <span style=\"color: #0000ff;\">var</span> f = <span style=\"color: #0000ff;\">function</span><span style=\"color: #000000;\"> (a,b){\n\n      </span><span style=\"color: #0000ff;\">return</span> a+<span style=\"color: #000000;\">b\n\n  }\n\n  let f </span>= (a,b) =&gt; a+<span style=\"color: #000000;\">b\n\n \n\n </span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">如果返回值是对象</span>\n\n  <span style=\"color: #0000ff;\">var</span> f = <span style=\"color: #0000ff;\">function</span><span style=\"color: #000000;\"> (a,b){\n\n      </span><span style=\"color: #0000ff;\">return</span><span style=\"color: #000000;\"> {a:a,b:b}\n\n  }\n\n  let f </span>= (a,b) =&gt; { <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">不知道的情况下，可以直接蒋es5中的函数内容复制</span>\n\n      <span style=\"color: #0000ff;\">return</span><span style=\"color: #000000;\"> {a:a,b:b}\n\n  }\n\n  let f </span>= (a,b) =&gt; ({a:a,b:b}) <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">加括号</span>\n\n \n\n<span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">如果返回值是函数</span>\n<span style=\"color: #000000;\">\n let f </span>= (a,b) =&gt; { <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">不知道的情况下，可以直接蒋es5中的函数内容复制</span>\n\n      <span style=\"color: #0000ff;\">return</span> <span style=\"color: #0000ff;\">function</span><span style=\"color: #000000;\">(){a:a,b:b}\n\n  }\n\n let f </span>= (a,b) =&gt; { <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">不知道的情况下，可以直接蒋es5中的函数内容复制</span>\n\n      <span style=\"color: #0000ff;\">return</span><span style=\"color: #000000;\"> a()\n\n  }\n\n \n\n \n\n</span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">无返回值的情况</span>\n<span style=\"color: #000000;\">\n  let f2 </span>= v =&gt;<span style=\"color: #000000;\">{\n\n      </span><span style=\"color: #0000ff;\">if</span>(v&gt;=5<span style=\"color: #000000;\">){\n\n          </span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">...</span>\n<span style=\"color: #000000;\">\n      }\n\n  }\n\n </span></pre>\n</div>\n<p>&nbsp;</p>\n<p><span style=\"font-size: 15px;\"><strong>注意事项，不是所有情况都能使用</strong></span></p>\n<p>1. <span style=\"font-family: 宋体;\">箭头函数不能当作构造函数，不可以使用</span><span style=\"font-family: Calibri;\">new</span></p>\n<p>&nbsp;</p>\n<div class=\"cnblogs_code\">\n<pre>let f = (a,b) =&gt;<span style=\"color: #000000;\"> ({a:a,b:b})\n\n  </span><span style=\"color: #0000ff;\">var</span> Fun = name =&gt;<span style=\"color: #000000;\">{\n\n      </span><span style=\"color: #0000ff;\">this</span>.name =<span style=\"color: #000000;\"> name;\n\n  }\n\n  </span><span style=\"color: #0000ff;\">var</span> f1 = <span style=\"color: #0000ff;\">new</span> Fun();<span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">error</span></pre>\n</div>\n<p>&nbsp;</p>\n<p>2. <span style=\"font-family: 宋体;\">箭头函数没有原型对象</span></p>\n<p>3. <span style=\"font-family: 宋体;\">不能使用</span><span style=\"font-family: Calibri;\">Arguments </span><span style=\"font-family: 宋体;\">对象，但是可以使用rest代替</span></p>\n<p>&nbsp;&nbsp;</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: #0000ff;\">function</span><span style=\"color: #000000;\"> fun3(){\n\n      console.log(arguments[</span>2<span style=\"color: #000000;\">])\n\n  }\n\n  fun3(</span>1,2,3,4,56<span style=\"color: #000000;\">,);\n\n  </span><span style=\"color: #0000ff;\">var</span> fun3 =() =&gt;<span style=\"color: #000000;\">{\n\n      console.log(arguments[</span>2]);<span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">error</span>\n<span style=\"color: #000000;\">\n  }\n\n  </span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">代替argument是rest参数</span>\n\n  <span style=\"color: #0000ff;\">var</span> fun3 = (...value) =&gt;<span style=\"color: #000000;\">{\n\n      console.log(value[</span>2<span style=\"color: #000000;\">])\n\n  }</span></pre>\n</div>\n<p>&nbsp;</p>\n<p>4. this<span style=\"font-family: 宋体;\">指向，箭头函数的</span><span style=\"font-family: Calibri;\">this始终指向函数声明时所在的作用域下的this值</span><span style=\"font-family: 宋体;\">，而普通函数的</span><span style=\"font-family: Calibri;\">this</span><span style=\"font-family: 宋体;\">是指向的调用的对象</span></p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: #0000ff;\">//ES5 普通情况<br />var</span> str = 'abc';<span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">全局变量</span>\n\n   <span style=\"color: #0000ff;\">var</span> obj = { <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">定义一个对象</span>\n<span style=\"color: #000000;\">\n       str:</span>'xyz', <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">对象中的属性</span>\n<span style=\"color: #000000;\">\n       getStr:</span><span style=\"color: #0000ff;\">function</span>(){<span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">对象中的方法</span>\n<span style=\"color: #000000;\">\n           console.log(</span><span style=\"color: #0000ff;\">this</span><span style=\"color: #000000;\">.str);\n\n       }\n\n   }\n\n  obj.getStr();</span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">xyz 调用者是obj</span>\n\n \n\n   <span style=\"color: #0000ff;\">var</span> z =<span style=\"color: #000000;\"> obj.getStr;\n\n   z();</span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">abc 调用者是window</span></pre>\n</div>\n<p>&nbsp;</p>\n<p>如果把obj稍作修改成箭头函数，那么this的指向是不同 的</p>\n<div class=\"cnblogs_code\">\n<pre>//ES6 情况<br /> <span style=\"color: #0000ff;\">var</span> str = 'abc';<span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">全局变量</span>\n   <span style=\"color: #0000ff;\">var</span> obj = { <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">定义一个对象</span>\n       str:'xyz', <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">对象中的属性</span>\n       getStr:<span style=\"color: #ff0000;\">()=&gt;</span>{<span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">对象中的方法</span>\n           console.log(<span style=\"color: #0000ff;\">this</span><span style=\"color: #000000;\">.str);\n       }\n   }\n  obj.getStr();</span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">abc  因为箭头函数永远指向定义他的对象的层级，例如obj是window定义的，所以此时的this指向window</span></pre>\n</div>\n<p>&nbsp;</p>\n<p>4. 箭头函数适用于 与this无关的回调，例如定时器，数组的方法回调</p>\n<p>&nbsp; &nbsp; &nbsp;箭头函数不适用与this 优化的回调，事件回调，对象方法（不适用不等于不能）</p>"
    },
    {
      "id": 14,
      "title": "ES6 - 模板字符串 ``",
      "time": "2021-02-25 17:56",
      "type": ["ES6","JavaScript"],
      "abstract": "ES6 引入新的生命字符串的方式，反写的引号``; 模板字面量 是允许嵌入表达式的字符串字面量。你可以使用多行字符串和字符串插值功能。它们在ES2015规范的先前版本中被称为“模板字符串”。",
      "content":"<p>ES6 <span style=\"font-family: 宋体;\">引入新的生命字符串的方式，反写的引号&nbsp;</span></p>\n<div class=\"cnblogs_code\">\n<pre> ` `</pre>\n</div>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>1.&nbsp;<span style=\"font-family: 宋体;\">声明</span><span style=\"font-family: Calibri;\">,&nbsp;</span><span style=\"font-family: 宋体;\">其实和别的字符串定义没啥区别</span></p>\n<div class=\"cnblogs_code\">\n<pre>let str =<span style=\"color: #000000;\"> `我是一个字符串`\n\nconsole.log(str, </span><span style=\"color: #0000ff;\">typeof</span> str);<span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">我是一个字符串 string</span></pre>\n</div>\n<p>&nbsp;</p>\n<p>2.&nbsp;<span style=\"font-family: 宋体;\">特点是：</span></p>\n<p><span style=\"font-family: 宋体;\">&nbsp; &nbsp; 1).&nbsp;</span><span style=\"font-family: 宋体;\">内容中可以直接出线换行符，但是不能出现单引号，双引号</span></p>\n<p>&nbsp;</p>\n<div class=\"cnblogs_code\">\n<pre>let str2 = `&lt;ul&gt;\n\n   &lt;li&gt;A&lt;/li&gt;\n\n  &lt;li&gt;B&lt;/li&gt;\n\n&lt;/ul&gt;`</pre>\n</div>\n<p>&nbsp;</p>\n<p><span style=\"font-family: 宋体;\">&nbsp;如果用单双引号，咱们是需要使用</span>+<span style=\"font-family: 宋体;\">号来拼接的</span></p>\n<p>&nbsp;</p>\n<div class=\"cnblogs_code\">\n<pre> let str2 = '&lt;ul&gt;' +\n        '&lt;li&gt;A&lt;/li&gt;' +\n        '&lt;li&gt;B&lt;/li&gt;' +\n        '&lt;/ul&gt;'</pre>\n</div>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p><span style=\"font-family: 宋体;\">&nbsp;&nbsp;　　2).&nbsp;</span><span style=\"font-family: 宋体;\">变量拼接</span></p>\n<p>&nbsp;</p>\n<div class=\"cnblogs_code\">\n<pre>let lovest = 'Alan'<span style=\"color: #000000;\">;\n\nlet output </span>= '是我的最爱'&nbsp; &nbsp;</pre>\n</div>\n<p>如果单双引号，我们需要</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</p>\n<div class=\"cnblogs_code\">\n<pre> let final = lovest +<span style=\"color: #000000;\"> output\n\n console.log(final);</span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> Alan是我的最爱</span></pre>\n</div>\n<p>&nbsp;</p>\n<p>但是用反引号</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</p>\n<div class=\"cnblogs_code\">\n<pre> let finalNew =<span style=\"color: #000000;\">  `${lovest}是我的最爱`\n\n console.log(finalNew);</span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">Alan是我的最爱</span></pre>\n</div>\n<p>&nbsp;</p>"
    },
    {
      "id": 15,
      "title": "ES6 - 变量解构赋值",
      "time": "2021-02-25 17:53",
      "type": ["ES6","JavaScript"],
      "abstract": "ES6允许按照一定的模式从数组和对象中提取值，对变量进行赋值，这就成为解构赋值; 遇到方法频繁调用，可以使用解构",
      "content":"<p class=\"p\">ES6允许按照一定的模式从数组和对象中提取值，对变量进行赋值，这就成为解构赋值/</p>\n<p class=\"p\">遇到方法频繁调用，可以使用解构</p>\n<p class=\"p\">&nbsp;</p>\n<p>1. 数组的解构</p>\n<div class=\"cnblogs_code\">\n<pre>const A = ['1','2','3'<span style=\"color: #000000;\">]\nlet [a,b,c] </span>=<span style=\"color: #000000;\"> A\nconsole.log(a);</span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">1</span>\nconsole.log(b);<span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">2</span>\nconsole.log(c);<span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">3</span></pre>\n</div>\n<p>2. 对象的解构</p>\n<p>&nbsp;</p>\n<div class=\"cnblogs_code\">\n<pre>const Alan =<span style=\"color: #000000;\"> {\n        name: </span>\"Alan\"<span style=\"color: #000000;\">,\n        dob: </span>\"1989\"<span style=\"color: #000000;\">,\n        age: </span><span style=\"color: #0000ff;\">function</span><span style=\"color: #000000;\"> () {\n            let year </span>= <span style=\"color: #0000ff;\">new</span><span style=\"color: #000000;\"> Date().getFullYear();\n            console.log(year </span>-<span style=\"color: #000000;\"> Alan.dob)\n        }\n    }\n    </span><span style=\"color: #008000;\">/*</span><span style=\"color: #008000;\">let {name, dob, age} = Alan;\n&nbsp;\n    console.log(name);//Alan\n    console.log(dob);//1989\n    console.log(age);// function\n    age();//32    方法可以正常调用\n    Alan.age()\n    Alan.age()\n    Alan.age()\n    //如果一直调用age发现，Alan一直重复 \n    //如果不适用let重定义,那么我们需要如此的调用Alan，如果会显得Alan是重复代码\n    console.log(Alan.name);\n    console.log(Alan.dob);\n    console.log(Alan.age);</span><span style=\"color: #008000;\">*/</span><span style=\"color: #000000;\">\n\n    let {age}</span>=<span style=\"color: #000000;\"> Alan;\n\n    console.log(age())</span></pre>\n</div>\n<p>&nbsp;</p>"
    },
    {
      "id": 16,
      "title": "ES6 - let / const",
      "time": "2021-02-25 17:51",
      "type": ["ES6","JavaScript"],
      "abstract": "ES2015(ES6) 新增加了两个重要的 JavaScript 关键字: let 和 const。let 声明的变量只在 let 命令所在的代码块内有效。const 声明一个只读的常量，一旦声明，常量的值就不能改变。",
      "content":"<p>&nbsp;</p>\n<p><span style=\"font-family: 宋体;\">相同点：都是块级变量</span></p>\n<p>&nbsp;</p>\n<p><span style=\"font-size: 18px;\">let&nbsp;<span style=\"font-family: 宋体;\">可赋值任意值，但是不能重复定义</span></span></p>\n<p>&nbsp;</p>\n<div class=\"cnblogs_code\">\n<pre>let a=0; let a = 2; <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">会报错，说a已经被定义</span></pre>\n</div>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p><span style=\"font-family: 宋体;\">块级作用域</span></p>\n<p>&nbsp;</p>\n<p><span style=\"font-family: 宋体;\">尽在作用域内能取值，外部是取不到的</span></p>\n<p>&nbsp;</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: #000000;\">        {\n          let a </span>= 0<span style=\"color: #000000;\">;\n        }\n        console.log(a); </span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">a is undefined</span>\n        <span style=\"color: #0000ff;\">for</span> (<span style=\"color: #0000ff;\">var</span> i = 0; i &lt; items.length; i++<span style=\"color: #000000;\">) {\n            item[i].onclick </span>= <span style=\"color: #0000ff;\">function</span><span style=\"color: #000000;\"> () {\n                item[i].style.background </span>= 'red'<span style=\"color: #000000;\">\n            }\n        }</span></pre>\n</div>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p><span style=\"font-family: 宋体;\">此时点击</span>div<span style=\"font-family: 宋体;\">。点击事件会报错，因为它本身走的回调函数是</span>item[3].style</p>\n<p><span style=\"font-family: 宋体;\">因为&nbsp;</span>i&nbsp;<span style=\"font-family: 宋体;\">其实在全局变量中保存的，他是递增的，</span>i&nbsp;<span style=\"font-family: 宋体;\">在循环结束时的值为</span>3<span style=\"font-family: 宋体;\">（</span>windows.i<span style=\"font-family: 宋体;\">）；</span></p>\n<p><span style=\"font-family: 宋体;\">但是如果此时把</span>var i&nbsp;<span style=\"font-family: 宋体;\">换成</span>let i&nbsp;<span style=\"font-family: 宋体;\">的话，就不会影响</span>, <span style=\"font-family: 宋体;\">因为</span>let<span style=\"font-family: 宋体;\">只在其作用域内有效</span></p>\n<p><span style=\"font-family: 宋体;\">更形象的表达就是：</span></p>\n<p>&nbsp;</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: #000000;\">{\n        let i</span>=0<span style=\"color: #000000;\">;\n        item[</span>0].onclick = <span style=\"color: #0000ff;\">function</span><span style=\"color: #000000;\"> (){\n            item[</span>0].style.background = 'red'<span style=\"color: #000000;\">\n        }\n    }\n    {\n        let i</span>=1<span style=\"color: #000000;\">;\n        item[</span>1].onclick = <span style=\"color: #0000ff;\">function</span><span style=\"color: #000000;\"> (){\n            item[</span>1].style.background = 'red'<span style=\"color: #000000;\">\n        }\n    }\n    {\n        let i</span>=2<span style=\"color: #000000;\">;\n        item[</span>2].onclick = <span style=\"color: #0000ff;\">function</span><span style=\"color: #000000;\"> (){\n            item[</span>2].style.background = 'red'<span style=\"color: #000000;\">\n        }\n    }</span></pre>\n</div>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p><strong><span style=\"color: #000000; font-size: 18px;\">const <span style=\"font-family: 宋体;\">定义常量（常量：值不能修改的量为常量）</span></span></strong></p>\n<ul>\n<li><span style=\"font-family: 宋体;\">可赋值任意值，</span>\n<ul>\n<li><span style=\"font-family: 宋体;\">必须有初始值</span>\n<ul>\n<li>const A <span style=\"font-family: 宋体;\">是会报错的</span></li>\n<li><span style=\"font-family: 宋体;\">潜规则</span>&nbsp;<span style=\"font-family: 宋体;\">常量命名是要大写的，但是小写也没问题。</span></li>\n<li><span style=\"font-family: 宋体;\">常量的值不能被修改</span></li>\n<li><span style=\"font-family: 宋体;\">例如</span>&nbsp;const A = 0; A = 2;<span style=\"font-family: 宋体;\">时会报错的</span></li>\n</ul>\n</li>\n<li><span style=\"font-family: 宋体;\">块级作用域</span>\n<ul>\n<li><span style=\"font-family: 宋体;\">同</span>let</li>\n</ul>\n</li>\n<li><span style=\"font-family: 宋体;\">对于数组和对象的元素做修改，不算做对常量的修改，不会报错，</span></li>\n</ul>\n</li>\n</ul>\n<div class=\"cnblogs_code\">\n<pre>const A = ['1', '2', '3'<span style=\"color: #000000;\">];\n\nA.push(</span>'4');</pre>\n</div>\n<ul>\n<li style=\"list-style-type: none;\">\n<ul>\n<li style=\"list-style-type: none;\">\n<ul>\n<li><span style=\"font-family: 宋体;\">此时不会报错，因为</span>A<span style=\"font-family: 宋体;\">对应的地址没有改变，元素改变，但是地址没有改变，所以数组和对象使用</span>const<span style=\"font-family: 宋体;\">最为稳妥的，避免被修改数据值</span></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>&nbsp;</p>"
    },
    {
      "id": 17,
      "title": "ES6 - Map() / Set()的用法",
      "time": "2021-02-19 13:25",
      "type": ["ES6","JavaScript"],
      "abstract": "Map是一组键值对的结构，具有极快的查找速度。set是类似组数，返回的对象只有值，没有键值，创建自带去重.",
      "content":"<h1 class=\"postTitle\"><code>Map</code>是一组键值对的结构，具有极快的查找速度。</h1>\n<h1><span style=\"font-size: 14px;\">声明&nbsp;</span></h1>\n<div class=\"postBody\">\n<div id=\"cnblogs_post_body\" class=\"blogpost-body\">\n<div class=\"cnblogs_code\">\n<pre>var map = new Map();<br />const getmap = new Map([['aa',1],['bb',2]]);</pre>\n</div>\n<p>设值</p>\n<div class=\"cnblogs_code\">\n<pre>map.set(\"key\",\"value\");<br /><br /><br /></pre>\n<p>由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉：</p>\n<p>例如： map.set(\"Alan\",\"B\");</p>\n<p>　　　 map.set(\"Alan\",\"A\");</p>\n<p>　　&nbsp; &nbsp;map.get(\"Alan);&nbsp; // A</p>\n<p>　　　　map.set(\"change\",function(){///});</p>\n</div>\n<p>size (等同于length)</p>\n<div class=\"cnblogs_code\">\n<pre>map.size();</pre>\n</div>\n<p>取值</p>\n<div class=\"cnblogs_code\">\n<pre>map.get(\"key\");</pre>\n</div>\n<p>判断key是否存在</p>\n<div class=\"cnblogs_code\">\n<pre>map.has(\"key\");</pre>\n</div>\n<p>&nbsp;删除key</p>\n<div class=\"cnblogs_code\">\n<pre>map.<span style=\"color: #0000ff;\">delete</span>(\"key\");</pre>\n</div>\n<p>&nbsp;</p>\n<p>&nbsp;清空map</p>\n<div class=\"cnblogs_code\">\n<pre>map.clear();</pre>\n</div>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>Array 中也存在map方法，容易让初始者混淆。 这是两个完全不懂得概念和方法。</p>\n<p>array.map(function(currentValue,index,arr), thisValue)&nbsp; &nbsp;改方法是属于数组的一种操作方法</p>\n<p><br />例如 array = [1,2,3,4,5];</p>\n<p>&nbsp;</p>\n<p>currentValue 就是循环array中的每一个值&nbsp; 1 2 3 4 5</p>\n<p>index 就是循环array的index值 0 1 2 3 4</p>\n<p>arr 就是 array本身[1,2,3,4,5]</p>\n<p>如果想要在array的基础上，计算出新的一个数组，同时该数组还不能被改变，那么就用到了.map()方法</p>\n<p>&nbsp;</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: #0000ff;\">var</span> array2 = array.map(<span style=\"color: #0000ff;\">function</span><span style=\"color: #000000;\">(currentValue, index, arr){\n\n　　</span><span style=\"color: #0000ff;\">return</span> currentValue * 2<span style=\"color: #000000;\"> \n\n})</span></pre>\n</div>\n<p>&nbsp;</p>\n<p>此时就会返回新数组array2 = [2,4,6,8,10 ]</p>\n<p>此时 array 没有改变 还是 [1,2,3,4,5]</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<h1>set是类似组数，返回的对象只有值，没有键值。创建自带去重</h1>\n<p>&nbsp;</p>\n<h1>声明&nbsp;</h1>\n<div class=\"postBody\">\n<div id=\"cnblogs_post_body\" class=\"blogpost-body\">\n<div class=\"cnblogs_code\">\n<pre>var set = new Set();</pre>\n</div>\n<p>设值</p>\n<div class=\"cnblogs_code\">\n<pre>set.add(\"newValue\");</pre>\n<p>因为set是没有key值的，所以只能添加一个</p>\n</div>\n<p>&nbsp;</p>\n<p>size (等同于length)</p>\n<div class=\"cnblogs_code\">\n<pre>set.size();</pre>\n</div>\n<p>判断key是否存在</p>\n<div class=\"cnblogs_code\">\n<pre>set.has(\"newValue\");</pre>\n</div>\n<p>&nbsp;删除元素</p>\n<div class=\"cnblogs_code\">\n<pre>set.delete(\"newValue\");</pre>\n</div>\n<p>&nbsp;</p>\n<p>&nbsp;清空set</p>\n<div class=\"cnblogs_code\">\n<pre>set.clear();</pre>\n</div>\n<p>&nbsp;</p>\n<p>&nbsp;set可用for...of...遍历</p>\n<p>for(let v of set){</p>\n<p>　　console.log(v)</p>\n<p>}</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n</div>\n</div>\n</div>\n</div>"
    },
    {
      "id": 18,
      "title": "IOS 最新开发上架流程 以及发布打包注意事项",
      "time": "2021-02-09 14:27",
      "type": ["IOS"],
      "abstract": "IOS 最新开发上架流程 以及发布打包注意事项",
      "content":"<p>一.&nbsp;&nbsp;获取开发账号，就是<a href=\"https://developer.apple.com/\" target=\"_blank\">申请Apple账号</a>，然后购买服务，可个人，可企业 。</p>\n<p>二. 登陆账号</p>\n<p>　1. 进去开发者首页，</p>\n<p>　<img src=\"https://img2020.cnblogs.com/blog/1553313/202102/1553313-20210209134856836-656796554.png\" alt=\"\" loading=\"lazy\" />&nbsp;</p>\n<p>&nbsp; 2. 点击&nbsp; Certificates, Identifiers &amp; Profiles,</p>\n<p>&nbsp; &nbsp; &nbsp; 首先创建 证书certifcates</p>\n<p>　　<img src=\"https://img2020.cnblogs.com/blog/1553313/202102/1553313-20210209135040536-1447164539.png\" alt=\"\" loading=\"lazy\" /></p>\n<p>&nbsp; &nbsp; &nbsp; 其次，根据不同需求选择，一般情况，开发选择Apple Development, 发布版本选择 Apple Distribution<img src=\"https://img2020.cnblogs.com/blog/1553313/202102/1553313-20210209135040536-1447164539.png\" alt=\"\" loading=\"lazy\" /></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;<img src=\"https://img2020.cnblogs.com/blog/1553313/202102/1553313-20210209135138020-46705440.png\" alt=\"\" loading=\"lazy\" /></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp; &nbsp; &nbsp;下一步</p>\n<p><img src=\"https://img2020.cnblogs.com/blog/1553313/202102/1553313-20210209135449268-1959409045.png\" alt=\"\" loading=\"lazy\" /></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>　　这里就需要用到Mac证书，此时需要使用mac来手动创建证书：步骤如下：</p>\n<p>&nbsp; &nbsp; &nbsp; &nbsp;搜索并打开钥匙串访问（keychain），在证书助理中，选择从证书颁发机构请求证书</p>\n<p>　　<img src=\"https://img2020.cnblogs.com/blog/1553313/202102/1553313-20210209135429666-419660790.png\" alt=\"\" loading=\"lazy\" /></p>\n<p>&nbsp;</p>\n<p>&nbsp; &nbsp; &nbsp; 输入你的信息</p>\n<p>&nbsp; &nbsp; &nbsp;&nbsp;<img src=\"https://img2020.cnblogs.com/blog/1553313/202102/1553313-20210209135659974-1674126399.png\" alt=\"\" loading=\"lazy\" /></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp; &nbsp; &nbsp;&nbsp;<img src=\"https://img2020.cnblogs.com/blog/1553313/202102/1553313-20210209135712341-1773008198.png\" alt=\"\" loading=\"lazy\" /></p>\n<p>&nbsp;</p>\n<p>&nbsp; &nbsp;&nbsp;<img src=\"https://img2020.cnblogs.com/blog/1553313/202102/1553313-20210209135935236-1946648595.png\" alt=\"\" loading=\"lazy\" /></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp; &nbsp; &nbsp;此时就获取到了之前所需要的证书，</p>\n<p>&nbsp; &nbsp; &nbsp;选择你的证书，然后下一步</p>\n<p><img src=\"https://img2020.cnblogs.com/blog/1553313/202102/1553313-20210209140037624-1491600576.png\" alt=\"\" loading=\"lazy\" /></p>\n<p>&nbsp;</p>\n<p><img src=\"https://img2020.cnblogs.com/blog/1553313/202102/1553313-20210209141205711-1637805916.png\" alt=\"\" loading=\"lazy\" /></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>之后你就会进入到可下载页面，下载你创建好的证书，之后需要使用</p>\n<p>&nbsp;<img src=\"https://img2020.cnblogs.com/blog/1553313/202102/1553313-20210209140103050-1993255877.png\" alt=\"\" loading=\"lazy\" /></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;双击打开下载好的distribution.cer(开发证书ios_development.cer&nbsp;)等下载好的cer文件，这时，你的钥匙串访问中就会出现你的证书，右键导出（如果你右击没有导出，请在窗口顶部选择所有项目，找到后再右键）</p>\n<p>&nbsp;</p>\n<p><img src=\"https://img2020.cnblogs.com/blog/1553313/202102/1553313-20210209140504549-26280649.png\" alt=\"\" loading=\"lazy\" /></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;输入文件名、选择路径后点击 &ldquo;存储&rdquo;：</p>\n<p><img src=\"https://img2020.cnblogs.com/blog/1553313/202102/1553313-20210209141123507-850001174.png\" alt=\"\" loading=\"lazy\" /></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p> <br />输入密码及确认密码后点击 &ldquo;好&rdquo;：</p>\n<div class=\"aw-comment-upload-img-list active\"><a href=\"https://img-cdn-tc.dcloud.net.cn/uploads/article/20191112/7a1a08323e9216f2347911e5773e3b23.png\" rel=\"lightbox\" target=\"_blank\" data-fancybox-group=\"thumb\"><img src=\"https://img-cdn-tc.dcloud.net.cn/uploads/article/20191112/7a1a08323e9216f2347911e5773e3b23.png\" alt=\"\" class=\"img-polaroid\" title=\"\" /></a></div>\n<p>&nbsp;</p>\n<p>至此，我们已经完成了开发证书的制作（得到了 xxx.p12 证书文件），接下来，继续生成开发阶段所需的描述文件，在生成描述文件之前，需要先添加调试设备（iPhone 、iPad）</p>\n<p>&nbsp;</p>\n<p>然后创建Identifieers</p>\n<p><img src=\"https://img2020.cnblogs.com/blog/1553313/202102/1553313-20210209141314310-257199675.png\" alt=\"\" loading=\"lazy\" /></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p><img src=\"https://img2020.cnblogs.com/blog/1553313/202102/1553313-20210209141351533-1015117407.png\" alt=\"\" loading=\"lazy\" /></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;<img src=\"https://img2020.cnblogs.com/blog/1553313/202102/1553313-20210209141426956-1073647098.png\" alt=\"\" loading=\"lazy\" /></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>然后 勾选所需权限，和根据提示输入信息</p>\n<p>&nbsp;<img src=\"https://img2020.cnblogs.com/blog/1553313/202102/1553313-20210209141510399-670378088.png\" alt=\"\" loading=\"lazy\" /></p>\n<p>&nbsp;</p>\n<p>点击下一步后，就会生成确认页面，确认你输入的信息，然后点击register，完成创建Identifiers</p>\n<p><img src=\"https://img2020.cnblogs.com/blog/1553313/202102/1553313-20210209141601779-1167154822.png\" alt=\"\" loading=\"lazy\" /></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>注册完成后，生成profile</p>\n<p>&nbsp;</p>\n<p>选择的时候，如果是开发，就选择对应的Development下面对应的类型。发布的就选择发布的地方，我选择的app store发布来举例介绍：</p>\n<p><img src=\"https://img2020.cnblogs.com/blog/1553313/202102/1553313-20210209141651274-445477439.png\" alt=\"\" loading=\"lazy\" /></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;下一步后，就要选择你之前创建的Identifiers</p>\n<p><img src=\"https://img2020.cnblogs.com/blog/1553313/202102/1553313-20210209141846073-1209759110.png\" alt=\"\" loading=\"lazy\" /></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;之后就会提示确认信息</p>\n<p><img src=\"https://img2020.cnblogs.com/blog/1553313/202102/1553313-20210209141911003-1044676017.png\" alt=\"\" loading=\"lazy\" /></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>输入app信息，然后下一步</p>\n<p><img src=\"https://img2020.cnblogs.com/blog/1553313/202102/1553313-20210209141937553-1210600654.png\" alt=\"\" loading=\"lazy\" /></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>最后就生成了所需的profile文件</p>\n<p><img src=\"https://img2020.cnblogs.com/blog/1553313/202102/1553313-20210209142012044-781889036.png\" alt=\"\" loading=\"lazy\" /></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;下载，并需要配置到xcode中</p>\n<p>新建项目后，点击左侧的项目名称，然后再targets中，填写对应的Display name 和bundle indentier，这里的名称要保持和创建Identifiers的时候创建app Id的一致</p>\n<p><img src=\"https://img2020.cnblogs.com/blog/1553313/202102/1553313-20210209142159538-624471501.png\" alt=\"\" loading=\"lazy\" /></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>然后选择signing的证书，他会自动识别mac系统中对应的证书</p>\n<p>&nbsp;<img src=\"https://img2020.cnblogs.com/blog/1553313/202102/1553313-20210209142424145-32481112.png\" alt=\"\" loading=\"lazy\" /></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;至此，基本配置就好了，当你项目完成后，就可以打包上传构建项目</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p><strong>打包构建发布</strong></p>\n<p>注意事项：</p>\n<p>&nbsp;</p>\n<p>上传App Icon的时候，需要上传1024*1024的，而且不能有圆角效果和透明效果！使用1024*1024的图片，生成各个大小的icon，可以使用 Asset Catelog Creator.&nbsp; 会自动生成对应的Assets.xcassets文件夹，直接替换掉自己项目里面的就可以。</p>\n<p>&nbsp;</p>\n<p>点击 xcode - product - archive</p>\n<p><img src=\"https://img2020.cnblogs.com/blog/1553313/202102/1553313-20210209143150474-347942763.png\" alt=\"\" loading=\"lazy\" /></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;注意：如果Archive是灰色不能点击，说明你的项目选择的虚拟机启动，改为Any iOS 或者 你连接的真是手机，都可以。</p>\n<p><img src=\"https://img2020.cnblogs.com/blog/1553313/202102/1553313-20210209143254365-545707299.png\" alt=\"\" loading=\"lazy\" /></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>点击后，会进行打包，等待弹出弹窗：</p>\n<p>一般选择先验证Validate App，后提交发布Distribute App</p>\n<p>一直下一步就可以，如果有错误，根据提示百度，然后修复就可，通过验证后，直接提交发布Distribute App，但是再提交发布之前，必须在app store connect中 创建你的对应项目，否则就失败，提示你没有对应项目。其实就相当于提交发布的申请页面。</p>\n<p>地址：<a href=\"https://appstoreconnect.apple.com%20%20%20\" target=\"_blank\">https://appstoreconnect.apple.com</a>&nbsp;</p>\n<p><img src=\"https://img2020.cnblogs.com/blog/1553313/202102/1553313-20210209144159625-211398040.png\" alt=\"\" loading=\"lazy\" /></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p><img src=\"https://img2020.cnblogs.com/blog/1553313/202102/1553313-20210209144142442-206782173.png\" alt=\"\" loading=\"lazy\" /></p>\n<p>&nbsp;</p>\n<p>输入自己的信息，选择对应的套装ID，就是项目ID，然后创建，成功后就可以继续发布你的程序到该位置</p>\n<p>&nbsp;</p>\n<p>&nbsp;<img src=\"https://img2020.cnblogs.com/blog/1553313/202102/1553313-20210209144226677-1514877031.png\" alt=\"\" loading=\"lazy\" /></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>最后填写所有发布信息内容，xcode中提交的代码就会出现再构建项目中，选择对应版本，提交审核即可。</p>"
    },
    {
      "id": 19,
      "title": "JavaScript Arguments",
      "time": "2019-01-09 13:29",
      "type": ["JavaScript"],
      "abstract": "在函数代码中，使用特殊对象 arguments，开发者无需明确指出参数名，就能访问它们。arguments 是一个类数组对象。",
      "content":"<p>arguments 是一个类数组对象。</p>\n<p>后台其他的语言都有一种函数<strong>重载现象</strong>。就是函数名相同，但是传递的参数不同。属于不同的函数。但是JS中是没有重载现象的。JS中函数名相同，传递参数不同时，后面的会覆盖前面的。</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: #0000ff;\">function</span><span style=\"color: #000000;\"> fun(a,b) {\nconsole.log(</span>1<span style=\"color: #000000;\">);\n}\n\n</span><span style=\"color: #0000ff;\">function</span><span style=\"color: #000000;\"> fun(a,b,c) {\nconsole.log(</span>2<span style=\"color: #000000;\">);\n}\n\n</span><span style=\"color: #0000ff;\">function</span><span style=\"color: #000000;\"> fun(a,b,c,d) {\nconsole.log(</span>3<span style=\"color: #000000;\">);\n}\nfun(</span>1,2);</pre>\n</div>\n<p>最后的结果只会是 <strong>3</strong>. 因为最后一个function fun，<strong>覆盖</strong>了之前的function fun。</p>\n<p>&nbsp;</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: #0000ff;\">function</span><span style=\"color: #000000;\"> sum(a,b) {\n </span><span style=\"color: #0000ff;\">return</span> a+b+ arguments[2<span style=\"color: #000000;\">];\n}\nconsole.log(sum(</span>1,2,3,4,5,6));</pre>\n</div>\n<p>这里的最终结果是&nbsp; 1+2+3 =<strong> 6</strong>；因为arguments[2] = 3.&nbsp;</p>\n<p>这里arguments指导<strong>入的整个参数</strong>（1,2,3,4,5,6）;</p>\n<p>下图是让你看看这个arguments到底是什么。</p>\n<p><img src=\"https://img2018.cnblogs.com/blog/1553313/201901/1553313-20190109132825420-1179777029.png\" alt=\"\" /></p>\n<p>&nbsp;Arguments对象将我传入的6个参数以数组的形式保存在里面，还有保存了我传入函数的实参的个数（length）</p>"
    },
    {
      "id": 20,
      "title": "Microsoft Exchange Server AD FS",
      "time": "2019-01-07 10:16",
      "type": ["Microsoft Exchange Server"],
      "abstract": "关于Exchenge Server，当我们添加不同的功能的时候，最好每一个功能一个服务器，这样的话，坑会少，错误会少一点。比如你计划有AD DS， AD FS， AD Sync，最好分三个服务器来操作，防止出现影响",
      "content":"<p>关于Exchenge Server，当我们添加不同的功能的时候，最好每一个功能一个服务器，这样的话，坑会少，错误会少一点。比如你计划有AD DS， AD FS， AD Sync，最好分三个服务器来操作，防止出现影响。</p>\n<p>而且在操作的时候，一般使用Domain User， 而不是创建好服务器时的administrator账号。</p>\n<p>首先做的应该时AD DS，这里先创建一个主服务器，我们叫它DC1。 我这里的前提是在windows Server 2012 R2上部署域服务并将windows 10 添加到域中，我当时是看的这个博客学习的：http://blog.postcha.com/read/80</p>\n<p>然后创建新的服务器DC3_ADFS， 然后开始安装ADFS。在安装ADFS的时候，我们会涉及到IIS证书，所以我们需要再建一个服务器来作为我们安装下载证书的服务器DC4_IIS。</p>\n<p>&nbsp;</p>\n<p>这里先讲解IIS的下载使用。</p>\n<p>在主操作面板Add Roles and Features Wizard中，选择添加IIS，成功后，进入Internet Information Services Manager中，在右侧选择Create Self-Signed Certificate. 创建好后，就会再列表中展现，右键导出，再局域网中共享，在DC3_ADFS中下载使用。</p>\n<p><strong>注意</strong>：你的IIS域名必须和电脑名不同。因为电脑名会和你的IIS在注册的时候，抢SPN的注册。如果你的电脑名是DC4_IIS，直接用这个名字创建就行。因为已经和ADFS的电脑名不同。如果相同的情况下就会出现ADFS出现情况不能成功。这也是为什么不同功能要分开服务器的原因之一。如果你安装在一个服务器中，只能是先修改电脑名，创建IIS，然后再改回原先的电脑名，或者反过来操作创建了IIS后，更改电脑名。</p>\n<p><img src=\"https://img2018.cnblogs.com/blog/1553313/201901/1553313-20190107095000554-2011414061.png\" alt=\"\" /></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>下面开始正式安装AD FS：</p>\n<p>同样在主操作面板Add Roles and Features Wizard中，选择添加ADFS。按照默认下一步，直到出现server roles。 点击安装Active Directory Federation Services。继续所有默认选项，直到安装结束。</p>\n<p>然后就会出现让你配置Configure the&nbsp;federation&nbsp;service on this server. (可以直接点击这里配置，也可以关闭，之后再界面右上角的小旗子找到。)</p>\n<p><img src=\"https://img2018.cnblogs.com/blog/1553313/201901/1553313-20190107095941845-1309291562.png\" alt=\"\" /></p>\n<p><img src=\"https://img2018.cnblogs.com/blog/1553313/201901/1553313-20190107095945751-290194205.png\" alt=\"\" /></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;点击配置后，</p>\n<p>1. Conncet to AD DS - 他会默认当前用户登录，一般不用更改用户，下一步</p>\n<p><img src=\"https://img2018.cnblogs.com/blog/1553313/201901/1553313-20190107100111463-644204719.png\" alt=\"\" /></p>\n<p>2. 导入之前准备好的 IIS证书,输入之前导出设置的密码。</p>\n<p><img src=\"https://img2018.cnblogs.com/blog/1553313/201901/1553313-20190107100234018-2000058502.png\" alt=\"\" /></p>\n<p>&nbsp;</p>\n<p>&nbsp;3.Specify Service Account - 选择默认选项（第二个），输入当前用户帐号密码。</p>\n<p><img src=\"https://img2018.cnblogs.com/blog/1553313/201901/1553313-20190107100331705-839372792.png\" alt=\"\" /></p>\n<p>&nbsp;</p>\n<p>4. Specify database - 保持默认选项，下一步，如果提示已经有数据库，选择覆盖重新创建。(第一次不会有，如果卸载了重现装的AD FS就会有)</p>\n<p>5. 一直默认，点击 next，直到配置成功。<br /><img src=\"https://img2018.cnblogs.com/blog/1553313/201901/1553313-20190107100538340-679108802.png\" alt=\"\" /></p>\n<p>&nbsp;</p>\n<p>到这里就安装完成了。下面是来验证。</p>\n<p>在浏览器中进入一下连接：</p>\n<p>https://&lt;internalcrm&gt;.&lt;domain&gt;.com/adfs/ls/idpinitiatedsignon.xml<br />https://&lt;internalcrm&gt;.&lt;domain&gt;.com/federationmetadata/2007-06/federationmetadata.xml<br />https://&lt;internalcrm&gt;.&lt;domain&gt;.com/adfs/services/trust/mex</p>\n<p>例如：https://DC3_ADFS.domain.com//adfs/ls/idpinitiatedsignon.xml</p>\n<p>一般情况下，如果安装有问题，第一个连接时打开失败的。一般是503错误。这种情况就是之前提到的SPN可能出现了问题。如果不是第一次安装，需要通过cmdlet清除缓存。</p>\n<p>如果以上都没有问题，我们就可以在Office Admin Center中配置我们自己的domain，而不是使用onmicrosoft。</p>\n<p>这个看官方文档就有具体操作，前提是有自己的域名。配置完成后，在用DC1中的用户找到你的domain user， 选择Account，改变后缀。</p>\n<p><img src=\"https://img2018.cnblogs.com/blog/1553313/201901/1553313-20190107101052884-1387169609.png\" alt=\"\" /></p>\n<p>其实到这里还差最后一步， 在AD Sync服务器中，打开AAD Connect, 然后选择&nbsp;configure the Change User Sign-in， 然后选择 Federation Service。</p>\n<p>配置成功后，我们就可以用浏览器进入&nbsp;portal.office.com 然后用你的本地用户名登录，比如adsync@domain.com，如果成功，一说明你的同步成功了，二说明你的AD FS成功了。&nbsp;</p>\n<p>&nbsp;</p>"
    },
    {
      "id": 21,
      "title": "Microsoft Exchange Server AD Sync",
      "time": "2019-01-07 09:42",
      "type": ["Microsoft Exchange Server"],
      "abstract": "关于Exchenge Server，当我们添加不同的功能的时候，最好每一个功能一个服务器，这样的话，坑会少，错误会少一点。比如你计划有AD DS， AD FS， AD Sync，最好分三个服务器来操作，防止出现影响。而且在操作的时候，一般使用Domain User， 而不是创建好服务器时的administrator账号。首先做的应该时AD DS，这里先创建一个主服务器，我们叫它DC1。 我这里的前提是在windows Server 2012 R2上部署域服务并将windows 10 添加到域中",
      "content":"<p>关于Exchenge Server，当我们添加不同的功能的时候，最好每一个功能一个服务器，这样的话，坑会少，错误会少一点。比如你计划有AD DS， AD FS， AD Sync，最好分三个服务器来操作，防止出现影响。</p>\n<p>而且在操作的时候，一般使用Domain User， 而不是创建好服务器时的administrator账号。</p>\n<p>首先做的应该时AD DS，这里先创建一个主服务器，我们叫它DC1。 我这里的前提是在windows Server 2012 R2上部署域服务并将windows 10 添加到域中，我当时是看的这个博客学习的：http://blog.postcha.com/read/80</p>\n<p>然后我们要再创建一个服务器（DC2_ADSync）来装 AD Sync, 在服务器的浏览器中，下载并安装 Azure AD Connect。这个很简单，安装完后，在开始菜单中就会有如下图一样的4个Azure AD Connect的功能：</p>\n<p><img src=\"https://img2018.cnblogs.com/blog/1553313/201901/1553313-20190107093252753-464283490.png\" alt=\"\" /></p>\n<p>运行&nbsp;Azure AD Connect，根据步骤操作，选择CUstomnize synchronization options.</p>\n<p>&nbsp;<img src=\"https://img2018.cnblogs.com/blog/1553313/201901/1553313-20190107093333307-1762156629.png\" alt=\"\" /></p>\n<p>输入你的账号连接。 再Optional Features中，选择 Password hash&nbsp;synchronization.</p>\n<p>&nbsp;<img src=\"https://img2018.cnblogs.com/blog/1553313/201901/1553313-20190107093449819-973382022.png\" alt=\"\" /></p>\n<p>然后一直下一步，按照默认选项。</p>\n<p>如果没用同步，你需要通过powershell 来强制启动同步：</p>\n<div class=\"cnblogs_code\">\n<pre>Import-Module ADSync</pre>\n</div>\n<p>&nbsp;</p>\n<div class=\"cnblogs_code\">\n<pre>Start-ADSyncSyncCycle -PolicyType Initial</pre>\n</div>\n<p>&nbsp;</p>\n<p>之后就可以打开菜单中的Synchronization Service来查看同步状态。如果你无法打开，提示需要用管理员身份打开，你需要给Domain User配置权限。</p>\n<p>在DC1中的操作界面右上角的manage中，打开Computer Management，首先添加管理员权限，其次还要赋予AD Sync的权限。之后就可以打开Synchronization Service了。</p>\n<p><img src=\"https://img2018.cnblogs.com/blog/1553313/201901/1553313-20190107093749721-574652918.png\" alt=\"\" /></p>\n<p>&nbsp;</p>"
    },
    {
      "id": 22,
      "title": "Microsoft Exchange Autodiscover",
      "time": "2019-01-04 09:37",
      "type": ["Microsoft Exchange Server"],
      "abstract": "Autodiscover是最小化用户配置，在经过一系列用户看不到的操作后，获取xml文件，这个文件是关于邮箱配置的所有信息(Main point),最终使用户直接通过账号密码就能绑定账号",
      "content":"<p>Autodiscover是最小化用户配置，在经过一系列用户看不到的操作后，获取xml文件，这个文件是关于邮箱配置的所有信息(Main point),最终使用户直接通过账号密码就能绑定账号.</p>\n<p>&nbsp;通过http://exrca.com， 你可以来测试你连接的整个流程。下图是给我自己进行的测试，当我输入账号密码后，所以用户看不到的autodiscover操作。</p>\n<p>&nbsp;</p>\n<p><img src=\"https://img2018.cnblogs.com/blog/1553313/201901/1553313-20190104093336263-185672863.png\" alt=\"\" /></p>\n<p>&nbsp;</p>"
    },
    {
      "id": 23,
      "title": "Microsoft Exchange Audit Logging",
      "time": "2019-01-04 09:33",
      "type": ["Microsoft Exchange Server"],
      "abstract": "Audit Logging主要分为两种类型，一种是监听邮箱级别的non-owner（非所有者）的操作，一种是监听管理员的操作。",
      "content":"<p>Audit Logging主要分为两种类型，一种是监听邮箱级别的non-owner（非所有者）的操作，一种是监听管理员的操作。</p>\n<p>Non-owner： 比如我所共享的邮件被删除了，我可以通过audit logging来查询是谁操作的。</p>\n<p>Administrator audit logging： 这个是记录所有管理员的cmdlets操作，但是这些cmdlets不包括GET， SEARCH 和 TEST。</p>\n<p>这里需要注意的是，邮箱级别的non-owner的操作监听，默认情况是关闭的。我们必须用cmdlet激活才能开始监听记录。在没开通之前，之前的所有操作时没法监听查找的。而且，这个坚挺的最高记录时90内的一些操作。所有超过90天的记录是找不到的。所以呢，如果想要监听查找之前的，就需要人为的每隔一段时间，保存这个logging的xml文件。</p>\n<p><br />关于导出，用户需要有权限才可以导出，在permision中设置。而且，这个导出的记录是xml文件格式，而邮箱默认情况是锁定了xml附件操作，所以还需要给邮箱配置xml附件权限。&nbsp;&nbsp;</p>\n<p>&nbsp;</p>\n<p>运行一下代码来添加XML格式到文件类型到Outlook Web App列表中&nbsp;</p>\n<div class=\"cnblogs_code\">\n<pre>Set-OwaMailboxPolicy -Identity OwaMailboxPolicy-<span style=\"color: #0000ff;\">Default</span> -AllowedFileTypes @{add='.xml'}</pre>\n</div>\n<p>&nbsp;运行以下代码来给用户赋予Audit Logs的权限。</p>\n<div class=\"cnblogs_code\">\n<pre>New-ManagementRoleAssignment -Role <span style=\"color: #800000;\">\"</span><span style=\"color: #800000;\">Audit Logs</span><span style=\"color: #800000;\">\"</span> -User &lt;Identity&gt;</pre>\n</div>\n<p>&nbsp;</p>\n<p><br />&nbsp;</p>"
    },
    {
      "id": 24,
      "title": "Microsoft Exchange Mail Flow Rule",
      "time": "2019-01-03 13:06",
      "type": ["Microsoft Exchange Server"],
      "abstract": "说到Mail Flow Rule，我们一般会把它和Inbox Rule做对比。Mail Flow Rule又叫做 transport rule,是在邮件发送到服务器的时候就开始操作，而Inbox Rule是在邮件到达邮箱后才操作的。Mail Flow Rule只有管理员可以操作设置。Mail Flow Rule 和 Inbox Rule， 他们两个的设置是有去别的。Inbox Rule设置相对来说更多一点。Mail Flow Rule 的优先级要比Inbox Rule 高 ",
      "content":"<p>说到Mail Flow Rule，我们一般会把它和Inbox Rule做对比。</p>\n<p><br />Mail Flow Rule又叫做 transport rule,是在邮件发送到服务器的时候就开始操作，而Inbox Rule是在邮件到达邮箱后才操作的。</p>\n<p>Mail Flow Rule只有管理员可以操作设置。</p>\n<p>Mail Flow Rule 和 Inbox Rule， 他们两个的设置是有去别的。Inbox Rule设置相对来说更多一点。</p>\n<p>Mail Flow Rule 的优先级要比Inbox Rule 高&nbsp;</p>"
    },
    {
      "id": 25,
      "title": "Microsoft Exchange Inactive mailbox",
      "time": "2019-01-03 11:59",
      "type": ["Microsoft Exchange Server"],
      "abstract": "Inactive mailbox是指邮箱在开启了Litigation Hold 后，用户被删除后，其邮箱就变成了Inactive mailbox。\n\nInactive mailbox的查看再Security & Compliance中的Data Governance下的Retention， 点击...进入",
      "content":"<p>Inactive mailbox是指邮箱在开启了Litigation Hold 后，用户被删除后，其邮箱就变成了Inactive mailbox。</p>\n<p>Inactive mailbox的查看再Security &amp; Compliance中的Data Governance下的Retention， 点击...进入</p>\n<p>&nbsp; &nbsp;　　<img src=\"https://img2018.cnblogs.com/blog/1553313/201901/1553313-20190103115624961-2066857103.png\" alt=\"\" /></p>\n<p>&nbsp;</p>\n<p><br />Inactive mailbox恢复方式有两种：</p>\n<ol>\n<li>Recover：把原有的邮箱转化（convert）到新邮箱，所以在recover以后，inactive被删除（核心区别）<ol>\n<li>　　这种情况用于老员工辞职后回到公司。</li>\n\n</ol></li>\n<li>Restore：把所有邮件内容复制到新邮箱，可以restore archive文件夹<ol>\n<li>　　这种情况用于新员工接替旧员工的工作。</li>\n\n</ol></li>\n\n</ol>"
    },
    {
      "id": 26,
      "title": "Microsoft Exchange In-Place Hold and Litigation Hold",
      "time": "2019-01-03 11:52",
      "type": ["Microsoft Exchange Server"],
      "abstract": " In-Place Hold and Litigation Hold 是用来保留和管理邮件的一种设置。区别： • 本质：recovery folder mail 删除后到purge文件夹，启用了Litigation Hold后会锁住purge，正常情况下，purge会一段时间后自动删除",
      "content":"<p>In-Place Hold and Litigation Hold 是用来保留和管理邮件的一种设置。<br />区别： </p>\n<ol>\n<li>&nbsp;去向不同，<ol>\n<li>In-Place Hold ==&gt;&nbsp;discoverHold&nbsp;文件夹</li>\n<li>Litigation Hold ==&gt; purge文件夹</li>\n\n\n\n</ol></li>\n<li>Hold的点不同<ol>\n<li>In-Place hold 按需hold，比如：时间范围，关键词，from，to的user</li>\n<li>Litigation hold 全部（无脑）hold，但是这个功能要在mailbox feature中开启</li>\n\n\n\n</ol></li>\n\n\n\n</ol>\n<p><em id=\"__mceDel\">\t&bull; 本质：recovery folder mail 删除后到purge文件夹，启用了Litigation Hold后会锁住purge，正常情况下，purge会一段时间后自动删除。</em></p>"
    },
    {
      "id": 27,
      "title": "Microsoft Exchange eDiscovery",
      "time": "2019-01-03 11:44",
      "type": ["Microsoft Exchange Server"],
      "abstract": "eDiscovery就是用来找回已删除的recoverable items邮件。现在因为改版，新的search到了Security & Compliance中的Search & investigation； 传统的eDiscovery需要再eDiscovery management中添加成员，赋予权限；需要注意的一点是，当用命令操作的时候，先要new一个search，但是它不会自动搜索，需要手动启动搜索",
      "content":"<p>eDiscovery就是用来找回已删除的recoverable items邮件。</p>\n<p>现在因为改版，新的search到了Security &amp; Compliance中的Search &amp; investigation</p>\n<p>传统的eDiscovery需要再eDiscovery management中添加成员，赋予权限</p>\n<p>需要注意的一点是，当用命令操作的时候，先要new一个search，但是它不会自动搜索，需要手动启动搜索</p>\n<div class=\"cnblogs_code\">\n<pre>Start-MailboxSearch <span style=\"color: #800000;\">\"</span><span style=\"color: #800000;\">name of the rule</span><span style=\"color: #800000;\">\"</span></pre>\n</div>\n<p>搜索结束后，你可以预览，也可以导出，到处的文件类型是pst文件，需要用outlook打开。</p>"
    },
    {
      "id": 28,
      "title": "Microsoft Exchange Retention Policy",
      "time": "2019-01-03 11:36",
      "type": ["Microsoft Exchange Server"],
      "abstract": "这个图是最重要的一个图，需要熟记。",
      "content":"<p style=\"text-align: left;\">这个图是最重要的一个图，需要熟记。</p>\n<p style=\"text-align: left;\">&nbsp;</p>\n<p><img src=\"https://img2018.cnblogs.com/blog/1553313/201901/1553313-20190103111155306-178228534.png\" alt=\"\" /></p>\n<p>&nbsp;</p>\n<p>Retention Policy</p>\n<p>Retention tag 是给邮件添加保留设置的，有delete and allow recover，Permanently Delete永久删除，move to archive</p>\n<ul>\n<li><strong>Delete and Allow Recovery</strong> allows the user to recover deleted items until the deleted item retention period for the mailbox database or the user is reached.</li>\n<li><strong>Permanently Delete</strong>&nbsp;purges the item from the mailbox database.</li>\n<li><strong>Move to Archive</strong>&nbsp;moves the item to the user's archive mailbox, if it exists. If a user doesn't have an archive mailbox, no action is taken. This action is available only for tags that are automatically applied to the entire mailbox (default) and tags applied by users to items or folders (personal tags).</li>\n</ul>\n<p>Regention tag有三种类型：</p>\n<ol>\n<li>Default policy tag (DPT)</li>\n<li>Retention policy tag (RPT)</li>\n<li>Personal tag&nbsp;</li>\n</ol>\n<p><strong>优先级</strong>是 3 - 2 - 1.</p>\n<p>&nbsp;</p>\n<p>区别：</p>\n<ol>\n<li>DPT和Persional tag 有delete and allow recover，Permanently Delete 和 Move to Archive, 而 RPT 没有Move to Archive。</li>\n<li>DPT是针对整个mailbox，RPT是针对系统文件夹（比如： Inbox, Sent Items, Deleted Items, Junk E-mail）</li>\n<li>DPT, RPT 只能是管理员应用，用户无法改变； Personal tag 是用户自己应用。</li>\n</ol>\n<p>&nbsp;</p>\n<p>Note：设置了Retention Policy后，是不能立即生效的，需要cmdlet 强制生效&nbsp;</p>\n<div class=\"cnblogs_code\">\n<pre>Start-ManagedFolderAssistant &ndash;Identity &lt;mailbox&gt;</pre>\n</div>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>Retention policy是将设置好的不同的tag组合起来，然后配置给mailbox<br />流程：</p>\n<ol>\n<li>创建 retention tags</li>\n<li>创建 retention policies</li>\n<li>把retention tags 添加到 retention policies中，即Retention Policy是用来组合Retention tags的</li>\n<li>然后在mailbox中apply mail feature中添加一种policy</li>\n<li>Managed Folder Assistant 处理 mailboxes</li>\n<li>Mailbox 被处理。</li>\n\n\n\n</ol>\n<p>&nbsp;下图是流程图，和Retention Tag的类型和区别。</p>\n<p>&nbsp;<img src=\"https://img2018.cnblogs.com/blog/1553313/201901/1553313-20190103111819173-1087869499.png\" alt=\"\" /></p>\n<p>&nbsp;</p>"
    },
    {
      "id": 29,
      "title": "JavaScript Array 操作",
      "time": "2018-12-13 13:43",
      "type": ["JavaScript"],
      "abstract": "shift:删除原数组第一项； unshift:将参数添加到原数组开头，并返回数组的长度；pop:删除原数组最后一项，并返回删除元素的值；如果数组为空则返回undefined；push:将参数添加到原数组末尾，并返回数组的长度；concat:返回一个新数组，是将参数添加到原数组中构成的；reverse:将数组反序；splice(start,deleteCount,val1,val2,...):从start位置开始删除deleteCount项，并从该位置起插入val1,val2,...；sort(order function):按指定的参数对数组进行排序. 一般后面跟随一个排序的function，默认空置为从小到大排列；slice(start,end):返回从原数组中指定开始下标到结束下标之间的项组成的新数组  slice后可跟负值，例如slice.(-4, -1)； join(separator):将数组的元素组起一个字符串，以separator为分隔符，省略的话则用默认用逗号为分隔符；",
      "content":"<p>其实以下操作，很多对于字符串同样适用。</p>\n<p><strong>shift</strong>:删除原数组第一项</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: #0000ff;\">var</span> a = [1,2,3,4,5<span style=\"color: #000000;\">];  \n\n</span><span style=\"color: #0000ff;\">var</span> b = a.shift(); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">a:[2,3,4,5] b:1</span></pre>\n</div>\n<p>&nbsp;</p>\n<p>&nbsp;<strong>unshift</strong>:将参数添加到原数组开头，并返回数组的长度</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: #0000ff;\">var</span> a = [1,2,3,4,5<span style=\"color: #000000;\">];   \n</span><span style=\"color: #0000ff;\">var</span> b = a.push(6,7); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">a:[1,2,3,4,5,6,7] b:7</span>\n</pre>\n</div>\n<p>&nbsp;</p>\n<p><strong>pop</strong>:删除原数组最后一项，并返回删除元素的值；如果数组为空则返回undefined&nbsp;</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: #0000ff;\">var</span> a = [1,2,3,4,5<span style=\"color: #000000;\">];   \n</span><span style=\"color: #0000ff;\">var</span> b = a.pop(); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">a:[1,2,3,4] b:5  </span></pre>\n</div>\n<p>&nbsp;</p>\n<p><strong>push</strong>:将参数添加到原数组末尾，并返回数组的长度&nbsp;</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: #0000ff;\">var</span> a = [1,2,3,4,5<span style=\"color: #000000;\">];   \n</span><span style=\"color: #0000ff;\">var</span> b = a.push(6,7); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">a:[1,2,3,4,5,6,7] b:7  </span></pre>\n</div>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p><strong>concat</strong>:返回一个新数组，是将参数添加到原数组中构成的&nbsp;&nbsp;</p>\n<div class=\"cnblogs_code\">\n<pre><strong><span style=\"color: #0000ff;\">var</span> a = [1,2,3,4,5<span style=\"color: #000000;\">];   \n</span><span style=\"color: #0000ff;\">var</span> b = a.concat(6,7); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">a:[1,2,3,4,5] b:[1,2,3,4,5,6,7]  </span></strong></pre>\n</div>\n<p>&nbsp;&nbsp;</p>\n<p><strong>reverse</strong>:将数组反序&nbsp;</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: #0000ff;\">var</span> a = [1,2,3,4,5<span style=\"color: #000000;\">];   \n</span><span style=\"color: #0000ff;\">var</span> b = a.reverse(); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> b = [5,4,3,2,1]</span></pre>\n</div>\n<p>&nbsp;</p>\n<p><strong>splice</strong>(start,deleteCount,val1,val2,...):从start位置开始删除deleteCount项，并从该位置起插入val1,val2,...&nbsp;</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: #0000ff;\">var</span> a = [1,2,3,4,5<span style=\"color: #000000;\">];   \n\n</span><span style=\"color: #0000ff;\">var</span> b = a.splice(2,2,7,8,9); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">a:[1,2,7,8,9,5] b:[3,4]   </span>\n\n<span style=\"color: #0000ff;\">var</span> b = a.splice(0,1); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">同shift   </span>\n<span style=\"color: #000000;\">\na.splice(</span>0,0,-2,-1); <span style=\"color: #0000ff;\">var</span> b = a.length; <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">同unshift   </span>\n\n<span style=\"color: #0000ff;\">var</span> b = a.splice(a.length-1,1); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">同pop   </span>\n<span style=\"color: #000000;\">\na.splice(a.length,</span>0,6,7); <span style=\"color: #0000ff;\">var</span> b = a.length;  <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">同push</span></pre>\n</div>\n<p>&nbsp;</p>\n<p>&nbsp;<strong>sort</strong>(order function):按指定的参数对数组进行排序. 一般后面跟随一个排序的function，默认空置为从小到大排列</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: #0000ff;\">var</span> a = [1,4,3,2,5<span style=\"color: #000000;\">];   <br />\n</span><span style=\"color: #0000ff;\">var</span> b = a.sort(); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> b = &nbsp;[1, 2, 3, 4, 5]</span></pre>\n</div>\n<p>&nbsp;</p>\n<p><strong>slice</strong>(start,end):返回从原数组中指定开始下标到结束下标之间的项组成的新数组&nbsp; slice后可跟负值，例如slice.(-4, -1)</p>\n<p>&nbsp;</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: #0000ff;\">var</span> a = [1,2,3,4,5<span style=\"color: #000000;\">];   <br />\n</span><span style=\"color: #0000ff;\">var</span> b = a.slice(2,5); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">a:[1,2,3,4,5] b:[3,4,5]  </span></pre>\n</div>\n<p>&nbsp;</p>\n<p>&nbsp;<strong>join</strong>(separator):将数组的元素组起一个字符串，以separator为分隔符，省略的话则用默认用逗号为分隔符&nbsp;</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: #0000ff;\">var</span> a = [1,2,3,4,5<span style=\"color: #000000;\">];  \n \n</span><span style=\"color: #0000ff;\">var</span> b = a.join(\"|\"); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">a:[1,2,3,4,5]  //b:\"1|2|3|4|5\"  </span>\n\n<span style=\"color: #0000ff;\">var</span> a = [1,2,3,4,5<span style=\"color: #000000;\">];  \n \n</span><span style=\"color: #0000ff;\">var</span> b = a.join(); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">a:[1,2,3,4,5]  //b:\" 1,2,3,4,5\"</span>\n\n<span style=\"color: #0000ff;\">var</span> a = [1,2,3,4,5<span style=\"color: #000000;\">];  \n \n</span><span style=\"color: #0000ff;\">var</span> b = a.join(\"\"); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">a:[1,2,3,4,5]  //b:\"12345\"</span></pre>\n</div>\n<p>&nbsp;</p>"
    },
    {
      "id": 30,
      "title": "JavaScript 闭包",
      "time": "2018-12-12 16:23",
      "type": ["JavaScript"],
      "abstract": "JavaScript 语言的特别之处就在于：函数内部可以直接读取全局变量，但是在函数外部无法读取函数内部的局部变量。\n\n所谓闭包就是说，一个函数能够访问其函数外部作用域中的变量，即指有权访问另一个函数作用域中的变量的函数。而创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量。\n\n闭包的作用在于，可以通过闭包，设计私有变量及方法。\n\n闭包的缺点就是常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。",
      "content":"<p>JavaScript&nbsp;语言的特别之处就在于：函数内部可以直接读取全局变量，但是在函数外部无法读取函数内部的局部变量。</p>\n<p>所谓闭包就是说，一个函数能够访问其函数外部作用域中的变量，即指有权访问另一个函数作用域中的变量的函数。而创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量。</p>\n<p>闭包的作用在于，可以通过闭包，<strong>设计私有变量及方法</strong>。</p>\n<p>闭包的<strong>缺点</strong>就是常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。</p>\n<p>&nbsp;</p>\n<p>案例一：</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: #0000ff;\">function</span><span style=\"color: #000000;\"> outer(a){\n　　</span><span style=\"color: #0000ff;\">var</span> x = 1<span style=\"color: #000000;\">;\n　　</span><span style=\"color: #0000ff;\">function</span><span style=\"color: #000000;\"> inner(y) {\n　　　　console.log(x</span>+<span style=\"color: #000000;\">y);\n　　}\n　　</span><span style=\"color: #0000ff;\">return</span><span style=\"color: #000000;\"> inner;\n}\n</span><span style=\"color: #0000ff;\">var</span>  i= outer(3); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">其实i内部储存的是inner函数的地址。因为outer() 返回了inner，所以其实i=inner(); </span>\n<span style=\"color: #000000;\">\ni(</span>5); <span style=\"color: #008000;\">//result: 6  </span><span style=\"color: #008000;\">这里就会使用局部变量，打印出a；本层虽没有a的定义，但是在innner的作用域链存在，所以输出1</span>\n<span style=\"color: #000000;\">\nouter(</span>3)(5); <span style=\"color: #008000;\">//result: 6  </span><span style=\"color: #008000;\">这里是把上面两步合并了一下输出。</span>\n<span style=\"color: #000000;\">\ninner(); </span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">但是这样调用，是不能成功的，会报错。</span></pre>\n</div>\n<p>&nbsp;</p>\n<p>案例二：</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: #0000ff;\">function</span><span style=\"color: #000000;\"> outer(){\n　　</span><span style=\"color: #0000ff;\">var</span> x = 1<span style=\"color: #000000;\">;\n　　</span><span style=\"color: #0000ff;\">function</span><span style=\"color: #000000;\"> inner() {\n　　　　</span><span style=\"color: #0000ff;\">return</span> x++<span style=\"color: #000000;\">;\n　　}\n　　</span><span style=\"color: #0000ff;\">return</span><span style=\"color: #000000;\"> inner;\n}\n</span><span style=\"color: #0000ff;\">var</span>  x=<span style=\"color: #000000;\"> outer(); \n\nconsole.log(x()); </span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: 1</span>\nconsole.log(x()); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: 2</span>\nconsole.log(x()); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: 3</span></pre>\n</div>\n<p>&nbsp;</p>\n<p>为什么是1，2，3呢？因为函数的闭包，记住了定义时所在的作用域，这个作用域中的变量不是一成不变的。</p>\n<p>案例三：</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: #0000ff;\">function</span><span style=\"color: #000000;\"> outer(){\n　　</span><span style=\"color: #0000ff;\">var</span> x = 1<span style=\"color: #000000;\">;\n　　</span><span style=\"color: #0000ff;\">function</span><span style=\"color: #000000;\"> inner() {\n　　　　</span><span style=\"color: #0000ff;\">return</span> x++<span style=\"color: #000000;\">;\n　　}\n　　</span><span style=\"color: #0000ff;\">return</span><span style=\"color: #000000;\"> inner;\n}\n</span><span style=\"color: #0000ff;\">var</span>  x=<span style=\"color: #000000;\"> outer(); \n</span><span style=\"color: #0000ff;\">var</span> y =<span style=\"color: #000000;\"> outer();\n\nconsole.log(x()); </span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: 1</span>\nconsole.log(y()); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: 1</span>\nconsole.log(x()); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: 2</span>\nconsole.log(y()); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: 2</span></pre>\n</div>\n<p>这里又为什么结果是这样呢？因为 x和y其实是两个不同的对象，相互之间不影响。 每次调用一个函数，都会产生新的闭包。新的闭包，语句全新，所处环境也是全新的。</p>\n<p>&nbsp;</p>"
    },
    {
      "id": 31,
      "title": "JavaScript 计算斐波那切数列",
      "time": "2018-12-12 14:12",
      "type": ["JavaScript"],
      "abstract": "斐波那切数列是：1， 1，2，3，5，8，13，21，34......(当前数等于前两个数之和)\n\n这里我们将使用递归函数，递归函数就是函数调用自身的函数。",
      "content":"<p>斐波那切数列是：1， 1，2，3，5，8，13，21，34......(当前数等于前两个数之和)</p>\n<p>这里我们将使用递归函数，递归函数就是函数调用自身的函数。</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: #0000ff;\">function</span><span style=\"color: #000000;\"> feibo(a) {\n  </span><span style=\"color: #0000ff;\">for</span> (<span style=\"color: #0000ff;\">var</span> i = 1; i &lt;= a; i++<span style=\"color: #000000;\">){\n      </span><span style=\"color: #0000ff;\">if</span>(a == 1 || a == 2<span style=\"color: #000000;\">) {\n        </span><span style=\"color: #0000ff;\">return</span> 1<span style=\"color: #000000;\">;        \n      }\n      </span><span style=\"color: #0000ff;\">else</span><span style=\"color: #000000;\">  {\n        </span><span style=\"color: #0000ff;\">return</span> feibo(a-1) +feibo (a-2<span style=\"color: #000000;\">);\n        }\n    }  \n}</span></pre>\n</div>\n<div class=\"cnblogs_code\">\n<pre>console.log(feibo(1)); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: 1</span>\nconsole.log(feibo(2)); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: 1</span>\nconsole.log(feibo(3)); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: 2</span>\nconsole.log(feibo(4)); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: 3</span>\nconsole.log(feibo(5)); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: 5</span>\nconsole.log(feibo(6)); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: 8</span>\nconsole.log(feibo(10)); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: 55</span></pre>\n</div>\n<p>&nbsp;</p>\n<p>Updata</p>\n<div class=\"cnblogs_code\">\n<pre>const fibonacci = num =&gt;<span style=\"color: #000000;\"> {\n  </span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> store the Fibonacci sequence you're going to generate inside an array and initialize the array with the first two numbers of the sequence</span>\n  const result = [0, 1<span style=\"color: #000000;\">]\n  </span><span style=\"color: #0000ff;\">for</span> (let i = 2; i &lt;= num; i++<span style=\"color: #000000;\">) {\n    </span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> push the sum of the two numbers preceding the position of i in the result array at the end of the result array</span>\n    const prevNum1 = result[i - 1<span style=\"color: #000000;\">]\n    const prevNum2 </span>= result[i - 2<span style=\"color: #000000;\">]\n    result.push(prevNum1 </span>+<span style=\"color: #000000;\"> prevNum2)\n  }\n  console.log(result)\n  console.log(result[num])\n}\nfibonacci(</span>15)</pre>\n</div>\n<p>&nbsp;</p>"
    },
    {
      "id": 32,
      "title": "JavaScript continue使用",
      "time": "2018-12-12 10:20",
      "type": ["JavaScript"],
      "abstract": "上一章讲了break的时候，break是会直接中断当前的循环。但是continue不会中断循环，而是会跳过当前条件，进行下一个条件。\n\n",
      "content":"<p>上一章讲了break的时候，break是会直接中断当前的循环。但是continue不会中断循环，而是会跳过当前条件，进行下一个条件。</p>\n<p>&nbsp;</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: #0000ff;\">for</span>( <span style=\"color: #0000ff;\">var</span> i = 1; i &lt; 5; i++<span style=\"color: #000000;\">){\n    \n            </span><span style=\"color: #0000ff;\">for</span>(<span style=\"color: #0000ff;\">var</span> j = 1;  j &lt; 5; j++<span style=\"color: #000000;\">){\n    \n                </span><span style=\"color: #0000ff;\">if</span>( j == 2<span style=\"color: #000000;\"> ) {\n             \n                </span><span style=\"color: #0000ff;\">continue</span>; <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">这个continue会直接结束当前条件语句，进行下一次的条件语句</span>\n<span style=\"color: #000000;\">            }\n\n            console.log(i, j);                \n        }\n} </span></pre>\n</div>\n<p>在上面这个案例中，当 i = 1,的时候， j = 1,循环继续进行，输出（1，1）；但是当 i = 1 , j = 2 的时候，上一张遇到了break，所以直接跳出当前循环，但是这里是continue，所以他会跳过当前条件，进行下一个条件，所以不会有当前的console.log(i, j); 会直接进入j=3;</p>\n<p>每当遇到 j = 2， 循环就会跳过，进行下一个条件。</p>\n<p>所以结果是 （1，1）， （1，3），（1，4），</p>\n<p>　　　　　 （2，1）， （2，3），（2，4），</p>\n<p>　　　　&nbsp; &nbsp; &nbsp;（3，1）， （3，3），（3，4），</p>\n<p>　　　　　 （4，1）， （4，3），（4，4）</p>\n<p>&nbsp;</p>\n<p>之前break中有个标签控制，continue当然也有</p>\n<div class=\"cnblogs_code\">\n<pre>label : <span style=\"color: #0000ff;\">for</span>( <span style=\"color: #0000ff;\">var</span> i = 1; i &lt; 5; i++<span style=\"color: #000000;\">){\n    \n            </span><span style=\"color: #0000ff;\">for</span>(<span style=\"color: #0000ff;\">var</span> j = 1;  j &lt; 5; j++<span style=\"color: #000000;\">){\n    \n                </span><span style=\"color: #0000ff;\">if</span>( j == 2<span style=\"color: #000000;\"> ) {\n             \n                </span><span style=\"color: #0000ff;\">continue</span> label; <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">这个continue会直接结束当前条件语句，进行下一次的条件语句</span>\n<span style=\"color: #000000;\">            }\n\n            console.log(i, j);                \n        }\n} </span></pre>\n</div>\n<p>在这个例子中，当遇到了continue，他就跳过了外层的for循环，外层跳过了，当然内层也不运行了。 所以当 i = 1,的时候， j = 1,循环继续进行，输出（1，1）；但是当 i = 1 , j = 2 的时候， 带有标签label的外层for循环就被跳过，所以就直接进行了 i = 2 的情况。当 i = 2,的时候， j = 1,循环继续进行，输出（2，1）；但是当 i = 2 , j = 2 的时候， 又一次遇到了continue，所以i = 2的循环有一次被跳过，所以就进行了 i = 3， i = 4；</p>\n<p>所以最后的结果是： （1，1），（2，1），（3，1），（4，1）</p>\n<p>&nbsp;</p>"
    },
    {
      "id": 33,
      "title": "JavaScript break 使用",
      "time": "2018-12-12 09:50",
      "type": ["JavaScript"],
      "abstract": "遇到break， 它会终端当前的循环（for, while, do while）",
      "content":"<p>遇到break， 它会终端当前的循环（for, while, do while）</p>\n<p>例如：</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: #0000ff;\">for</span>( <span style=\"color: #0000ff;\">var</span> i = 1; i &lt; 5; i++<span style=\"color: #000000;\">){\n\n    </span><span style=\"color: #0000ff;\">for</span>(<span style=\"color: #0000ff;\">var</span> j = 1;  j &lt; 5; j++<span style=\"color: #000000;\">){\n    \n        </span><span style=\"color: #0000ff;\">if</span>( j == 2<span style=\"color: #000000;\"> ) {\n             \n            </span><span style=\"color: #0000ff;\">break</span>; <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">这个break只能管理j，不能管理i</span>\n<span style=\"color: #000000;\">        }\n\n    console.log(i, j);                \n    }\n}</span></pre>\n</div>\n<p>在这个案例中，当 i = 1,的时候， j = 1,循环继续进行，输出（1，1）；但是当 i = 1 , j = 2 的时候， j所存在的for循环被中断，所以j始终是1， 但是i的for循环继续运行，所以最后 结果中j只能输出1； 所以结果是 （1，1）， （2，1）， （3，1）， （4，1）。</p>\n<p>那么我们如何让break管理i，而不是j呢？这里就会使用到标签， 给for循环一个标签控制。</p>\n<div class=\"cnblogs_code\">\n<pre>label : <span style=\"color: #0000ff;\">for</span>( <span style=\"color: #0000ff;\">var</span> i = 1; i &lt; 5; i++<span style=\"color: #000000;\">){\n    \n            </span><span style=\"color: #0000ff;\">for</span>(<span style=\"color: #0000ff;\">var</span> j = 1;  j &lt; 5; j++<span style=\"color: #000000;\">){\n    \n                </span><span style=\"color: #0000ff;\">if</span>( j == 2<span style=\"color: #000000;\"> ) {\n             \n                </span><span style=\"color: #0000ff;\">break</span> label; <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">这个break只能管理i，不能管理j</span>\n<span style=\"color: #000000;\">            }\n\n            console.log(i, j);                \n        }\n}    </span></pre>\n</div>\n<p>在上面这个案例中，当 i = 1,的时候， j = 1,循环继续进行，输出（1，1）；但是当 i = 1 , j = 2 的时候， j所存在的for循环遇到了break，但是break 后面有个标签label，所以这时，break控制的是有label标签的for循环，也就是有i的循环。所以呢，最外层的for循环就会被中断，所以最红终结果只有（1，1）.</p>\n<p>&nbsp;</p>"
    },
    {
      "id": 34,
      "title": "JavaScript 综合运算 （数字运算符+比较运算符+逻辑运算符）",
      "time": "2018-12-11 13:20",
      "type": ["JavaScript"],
      "abstract": "可能看了之前的文章，有人会疑问，为什么有的会返回fale，比如0，这里需要强调一下，什么情况下，会返回false；当该值为非值(当然我不确定是不是这么叫的)的时候，返回的结果就是false非值有：0 , false, “”, null, undefind, NaN(not a number)",
      "content":"<p>可能看了之前的文章，有人会疑问，为什么有的会返回fale，比如0，这里需要强调一下，什么情况下，会返回false；当该值为<span style=\"color: #ff0000;\">非值(当然我不确定是不是这么叫的)</span>的时候，返回的结果就是false</p>\n<p>非值有：0 , false, &ldquo;&rdquo;, null, undefind, NaN(not a number)</p>\n<p>&nbsp;</p>\n<p>综合运算顺序： 贴身的（!，++， --） ==&gt;&nbsp; 数字 ==&gt; 比较 ==&gt; 逻辑 ==&gt; 赋值</p>\n<p>&nbsp;</p>\n<p>题目：</p>\n<div class=\"cnblogs_code\">\n<pre><span style=\"color: #0000ff;\">var</span> a = 4<span style=\"color: #000000;\">;\n</span><span style=\"color: #0000ff;\">var</span> sum = 1 * (2 + 3)  &amp;&amp; a++ || 5 &gt; 6 &amp;&amp; 7&lt; 8 || 9<span style=\"color: #000000;\">;\nconsole.log (sum); </span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: 4</span></pre>\n</div>\n<p>解析：&nbsp;</p>\n<pre>var sum = 1 * (2 + 3)  &amp;&amp; a++ || 5 &gt; 6 &amp;&amp; 7&lt; 8 || 9<span>;</span><br /> 　　　　= 1 * （5） &amp;&amp; 4 || 5 &gt; 6 &amp;&amp; 7 &lt; 8 || 9;<br />　　　　 = 5 &amp;&amp; 4||false &amp;&amp; true || 9<br />　　　　 = 4 || false || 9 (短路语法)<br />　　　　 = 4 || 9<br /> 　　　　= 4</pre>"
    },
    {
      "id": 35,
      "title": "JavaScript 逻辑运算符 特殊字符 纯数字字符串",
      "time": "2018-12-11 12:49",
      "type": ["JavaScript"],
      "abstract": "逻辑运算符： &&， ||，! 运算顺序： ！==> && ==>||这个就简单了看一看就懂了.a&&b, a||b逻辑与&&，只要 a能被转换为false，那么结果就是a；否则返回b逻辑与||， 只要a能被转换为true，那么结果就是a；否则返回b",
      "content":"<p>逻辑运算符： &amp;&amp;， ||，!&nbsp;</p>\n<p>运算顺序： ！==&gt; &amp;&amp; ==&gt;||</p>\n<p>这个就简单了看一看就懂了.</p>\n<p>a&amp;&amp;b, a||b</p>\n<p>逻辑与&amp;&amp;，只要 a能被转换为<span style=\"color: #ff0000;\">false</span>，那么结果就是a；否则返回b</p>\n<p>逻辑与||， 只要a能被转换为<span style=\"color: #ff0000;\">true</span>，那么结果就是a；否则返回b</p>\n<p>1. &amp;&amp;</p>\n<div class=\"cnblogs_code\">\n<pre>console.log(\"123\" &amp;&amp; <span style=\"color: #0000ff;\">true</span>); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: true</span>\nconsole.log(\"\" &amp;&amp; <span style=\"color: #0000ff;\">true</span>); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result:  (空的什么也没有)</span>\nconsole.log(\"NaN\" &amp;&amp; <span style=\"color: #0000ff;\">false</span>); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: false</span>\nconsole.log(\"NaN\" &amp;&amp; <span style=\"color: #0000ff;\">true</span>); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: true</span>\nconsole.log(0 &amp;&amp; \"1\"); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: 0</span>\nconsole.log(undefined &amp;&amp; \"a\"); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: undefined</span>\nconsole.log(<span style=\"color: #0000ff;\">null</span> &amp;&amp; <span style=\"color: #0000ff;\">true</span>); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: null</span>\nconsole.log(Infinity &amp;&amp; 3); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: 3</span></pre>\n</div>\n<p>&nbsp;</p>\n<p>2.短路语法||。&nbsp;</p>\n<div class=\"cnblogs_code\">\n<pre>console.log(\"123\" || <span style=\"color: #0000ff;\">true</span>); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: 123</span>\nconsole.log(\"\" || <span style=\"color: #0000ff;\">true</span>); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result:  true</span>\nconsole.log(\"\" || 8); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result:  8</span>\nconsole.log(\"NaN\" || <span style=\"color: #0000ff;\">false</span>); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: NaN</span>\nconsole.log(\"NaN\" || <span style=\"color: #0000ff;\">true</span>); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: NaN</span>\nconsole.log(0 || \"1\"); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: 1</span>\nconsole.log(undefined|| \"a\"); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: a</span>\nconsole.log(<span style=\"color: #0000ff;\">null</span> || <span style=\"color: #0000ff;\">true</span>); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: true</span>\nconsole.log(Infinity || 3); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: infinity</span></pre>\n</div>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>小测试：&nbsp;</p>\n<p>　　1） false ||&nbsp; !false &amp;&amp; false || true</p>\n<p>　　　　=&nbsp;false || <span style=\"color: #ff0000;\">true</span> &amp;&amp; false || true)</p>\n<p>　　　　= false || <span style=\"color: #ff0000;\">true</span> || true</p>\n<p>　　　　= <span style=\"color: #ff0000;\">true</span></p>\n<div class=\"cnblogs_code\">\n<pre>console.log(<span style=\"color: #0000ff;\">false</span> || !<span style=\"color: #0000ff;\">false</span> &amp;&amp; <span style=\"color: #0000ff;\">false</span> || <span style=\"color: #0000ff;\">true</span>); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: true </span></pre>\n</div>\n<p>　　2） 1 &amp;&amp; &ldquo;hello\" || !false || !true &amp;&amp; null</p>\n<p>　　　　=&nbsp;1 &amp;&amp; &ldquo;hello\" || <span style=\"color: #ff0000;\">true</span>&nbsp;|| <span style=\"color: #ff0000;\">false</span> &amp;&amp; null</p>\n<p>　　　　=&nbsp;<span style=\"color: #ff0000;\">&ldquo;hello\"</span> ||&nbsp;true&nbsp;||<span style=\"color: #ff0000;\">&nbsp;false</span></p>\n<p><span style=\"color: #ff0000;\">　　　<span style=\"color: #000000;\">　=&nbsp;&ldquo;hello\" ||</span>&nbsp; false</span></p>\n<p>　　　　= \"hello\"</p>"
    },
    {
      "id": 36,
      "title": "JavaScript 比较运算符 特殊字符 纯数字字符串",
      "time": "2018-12-11 12:31",
      "type": ["JavaScript"],
      "abstract": "比较运算符： >, <, ==, ===, >=, <=, !=, !==, 和上一章的数字运算符一样，正常的大家都知道，这里还是主要讲一讲纯数字字符串 和 特殊字符（boolean,null, undefined, infinity, NaN）等特殊情况：",
      "content":"<p>比较运算符： &gt;, &lt;, ==, ===, &gt;=, &lt;=, !=, !==,&nbsp;</p>\n<p>和上一章的数字运算符一样，正常的大家都知道，这里还是主要讲一讲纯数字字符串 和 特殊字符（boolean,null, undefined, infinity, NaN）等</p>\n<p>特殊情况：</p>\n<p>1. 纯数字字符串与数字进行比较，会进行隐式计算。</p>\n<div class=\"cnblogs_code\">\n<pre>console.log('123' &lt; 12); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: true</span>\n<span style=\"color: #000000;\">\nconsole.log(</span>'123' &gt; 12); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: false</span></pre>\n</div>\n<p>2. 特殊字符与数字比较，同样会隐式计算。</p>\n<p>2.1 boolean, null</p>\n<p>它会将<strong>&nbsp;<span style=\"color: #ff0000;\">true = 1； false=0； null=0；</span></strong></p>\n<div class=\"cnblogs_code\">\n<pre>console.log(<span style=\"color: #0000ff;\">true</span> &lt; 12); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: true</span>\n<span style=\"color: #000000;\">\nconsole.log(</span><span style=\"color: #0000ff;\">true</span>  &gt; 12); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: false</span>\n<span style=\"color: #000000;\">\nconsole.log(</span><span style=\"color: #0000ff;\">true</span> == 1); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: true</span>\n<span style=\"color: #000000;\">\nconsole.log(</span><span style=\"color: #0000ff;\">false</span> == 0); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: true</span></pre>\n</div>\n<p>&nbsp;</p>\n<p>但是这里null有个特殊情况。 当<span style=\"color: #ff0000;\">null==0</span>的时候，按理说应该是true，但是它的结果是<span style=\"color: #ff0000;\">false</span>。&nbsp;</p>\n<div class=\"cnblogs_code\">\n<pre>console.log(<span style=\"color: #0000ff;\">null</span>== 0); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: false</span>\n<span style=\"color: #000000;\">\nconsole.log(</span><span style=\"color: #0000ff;\">null</span> &gt;= 0); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: true</span>\n<span style=\"color: #000000;\">\nconsole.log(</span><span style=\"color: #0000ff;\">null</span> &lt;= 0); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: true</span></pre>\n</div>\n<p>&nbsp;</p>\n<p><span style=\"color: #ff0000;\"><strong>===</strong></span>在判断两边时，会尽可能的让两边关系<strong><span style=\"color: #ff0000;\">不相等. <span style=\"color: #000000;\">===需要判断类型</span></span></strong></p>\n<div class=\"cnblogs_code\">\n<pre>console.log(&ldquo;12&rdquo; === 12); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: false</span>\n<span style=\"color: #000000;\">\nconsole.log(</span>12 === 12); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: true</span>\n<span style=\"color: #000000;\">\nconsole.log(</span><span style=\"color: #0000ff;\">true</span> === 1); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: false</span>\n<span style=\"color: #000000;\">\nconsole.log(</span><span style=\"color: #0000ff;\">false</span> === 0); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: false</span>\n<span style=\"color: #000000;\">\nconsole.log(</span><span style=\"color: #0000ff;\">null</span> === 0); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: false</span></pre>\n</div>\n<p>&nbsp;</p>\n<p>2.2 NaN, Infinity各自和自己比较</p>\n<div class=\"cnblogs_code\">\n<pre>console.log(NaN &gt; NaN ); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result:  false</span>\nconsole.log(NaN &lt; NaN); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result:  false</span>\nconsole.log(NaN == NaN); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: false</span>\nconsole.log(NaN != NaN); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: true</span>\nconsole.log(NaN === NaN); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: false</span>\nconsole.log(NaN !== NaN); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: true</span>\n<span style=\"color: #000000;\">\nconsole.log(Infinity</span>&gt; Infinity); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result:  false</span>\nconsole.log(Infinity&lt; Infinity); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result:  false</span>\nconsole.log(Infinity== Infinity); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: true</span>\nconsole.log(Infinity!= Infinity); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: false</span>\nconsole.log(Infinity=== Infinity); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: true</span>\nconsole.log(Infinity!== Infinity); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: false</span></pre>\n</div>\n<p>&nbsp;</p>\n<p>3. 非纯数字的字符串比较，不是比较字符串的长短，而是比较字符串的Unicode编码（顺序： 先数字，再大写字母，再小写字母；即数字&lt;大写&lt;小写），顺序靠前小于顺序靠后的。 如果第一个字符比较相同的话，就一次往后比较。</p>\n<div class=\"cnblogs_code\">\n<pre>console.log (\"12\" &lt; \"123\"); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: true</span>\n<span style=\"color: #000000;\">\nconsole.log (</span>\"12345689\" &lt; \"0\"); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: false</span>\n<span style=\"color: #000000;\">\nconsole.log (</span>\"12\" &lt; \"2\"); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: true</span>\n<span style=\"color: #000000;\">\nconsole.log (</span>\"A\" &lt; \"a\"); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: true</span>\n<span style=\"color: #000000;\">\nconsole.log (</span>\"normal\" &lt; \"north\"); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: true</span></pre>\n</div>\n<p>&nbsp;</p>\n<p>那么这里如果比较 3&gt;2&gt;1,他的结果是什么呢？</p>\n<p>其实他的运算顺序是 （3&gt;2）&gt;1&nbsp;</p>\n<p>　　　　　　　　　　 ==&gt; true&gt;1</p>\n<p>　　　　　　　　　　　　==&gt; 所以结果当然是......false</p>"
    },
    {
      "id": 37,
      "title": "JavaScript 数学运算符 特殊字符 纯数字字符串",
      "time": "2018-12-11 10:28",
      "type": ["JavaScript"],
      "abstract": "数学运算符 +， - ，* ，/ ，%， ()\n\n运算顺序： 先算乘除取余，再加减， 又小括号的先算小括号。\n\n正常运算大家都会，这里我主要讲一讲纯数字字符串 和 特殊字符（boolean,null, undefined, infinity, NaN）等",
      "content":"<p>数学运算符 +， - ，* ，/ ，%， ()</p>\n<p>运算顺序： 先算乘除取余，再加减， 又小括号的先算小括号。</p>\n<p>正常运算大家都会，这里我主要讲一讲纯数字字符串 和 特殊字符（boolean,null, undefined, infinity, NaN）等</p>\n<p>1. 纯数字的字符串也可以运算。只不过除了加法意外，都会进行隐式转换。 就是说我们不需要把它们进行格式转换，可以直接计算。</p>\n<p>例如：</p>\n<div class=\"cnblogs_code\">\n<pre>console.log ( \"20\" - 2); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: 18<br /></span>\nconsole.log ( \"20\" * 2); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: 40<br /><br /></span>console.log ( \"20\" / 2); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: 10<br /></span>\nconsole.log ( \"20\" % 2); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: 0</span></pre>\n</div>\n<p>&nbsp;</p>\n<p>2. 特殊字符 true, false, null 在进行乘法，加法同样会进行隐式转换。</p>\n<p>它会将<span style=\"color: #ff0000;\"><strong> true = 1； false=0； null=0；</strong></span></p>\n<p>例如：</p>\n<div class=\"cnblogs_code\">\n<pre>console.log ( 5 * <span style=\"color: #0000ff;\">true</span>); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: 5</span>\n<span style=\"color: #000000;\">\nconsole.log ( </span>5 * <span style=\"color: #0000ff;\">false</span>); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: 0</span>\n<span style=\"color: #000000;\">\nconsole.log ( </span>5 * <span style=\"color: #0000ff;\">null</span>); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: 0</span>\n<span style=\"color: #000000;\">\nconsole.log ( </span>5 + <span style=\"color: #0000ff;\">true</span>); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: 6</span>\n<span style=\"color: #000000;\">\nconsole.log ( </span>5 + <span style=\"color: #0000ff;\">false</span>); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: 5</span>\n<span style=\"color: #000000;\">\nconsole.log ( </span>5 + <span style=\"color: #0000ff;\">null</span>); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: 5</span></pre>\n</div>\n<p>3. undefined和其他字符粗汉与数字进行数学运算（除了加法），结果都是<span style=\"color: #ff0000;\">NaN</span>（not a number）</p>\n<p>例如：</p>\n<div class=\"cnblogs_code\">\n<pre>console.log ( 5 * undefined); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: NaN</span>\n<span style=\"color: #000000;\">\nconsole.log ( </span>5 *  \"Hello\"); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: NaN</span></pre>\n</div>\n<p>但是 如果是进行加法：</p>\n<div class=\"cnblogs_code\">\n<pre>console.log ( 5 + undefined); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: NaN</span>\n<span style=\"color: #000000;\">\nconsole.log ( </span>5 + \"Hello\"); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: 5Hello (这里是拼接)</span></pre>\n</div>\n<p>&nbsp;</p>\n<p>同样，如果NaN与数字进行数学运算，结果还是<span style=\"color: #ff0000;\">NaN</span>：</p>\n<p>例如：</p>\n<div class=\"cnblogs_code\">\n<pre>console.log ( 1 + NaN); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: NaN</span>\nconsole.log ( 1 - NaN); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: NaN</span>\nconsole.log ( 1 * NaN); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: NaN</span>\nconsole.log ( 1 / NaN); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: NaN</span>\nconsole.log ( 1 % NaN); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: NaN</span></pre>\n</div>\n<p>Infinity与数字进行数学运算，结果是什么呢？</p>\n<p>例如：</p>\n<div class=\"cnblogs_code\">\n<pre>console.log ( 1 + Infinity); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: Infinity</span>\nconsole.log ( 1 - Infinity); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: -Infinity</span>\nconsole.log ( 1 * Infinity); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: Infinity</span>\nconsole.log ( 1 / Infinity); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: 0</span>\nconsole.log ( 1 % Infinity); <span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">result: 1</span></pre>\n</div>\n<p>&nbsp;</p>\n<p>如有错误，请留言指教，谢谢。</p>\n<p>&nbsp;</p>"
    }
  ]
}
